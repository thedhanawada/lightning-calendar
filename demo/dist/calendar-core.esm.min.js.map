{"version":3,"file":"calendar-core.esm.min.js","sources":["../../core/timezone/TimezoneDatabase.js","../../core/timezone/TimezoneManager.js","../../core/events/Event.js","../../core/calendar/DateUtils.js","../../core/events/RRuleParser.js","../../core/events/RecurrenceEngine.js","../../core/performance/LRUCache.js","../../core/performance/AdaptiveMemoryManager.js","../../core/performance/PerformanceOptimizer.js","../../core/conflicts/ConflictDetector.js","../../core/events/EventStore.js","../../core/state/StateManager.js","../../core/calendar/Calendar.js","../../core/index.js"],"sourcesContent":["/**\n * TimezoneDatabase - Comprehensive IANA timezone database\n * Contains timezone rules for all major zones worldwide\n */\n\nexport class TimezoneDatabase {\n    constructor() {\n        // Comprehensive IANA timezone offset data (Standard Time)\n        // Offsets in minutes from UTC\n        this.timezones = {\n            // UTC\n            'UTC': { offset: 0, dst: null },\n            'GMT': { offset: 0, dst: null },\n\n            // Africa\n            'Africa/Abidjan': { offset: 0, dst: null },\n            'Africa/Accra': { offset: 0, dst: null },\n            'Africa/Addis_Ababa': { offset: 180, dst: null },\n            'Africa/Algiers': { offset: 60, dst: null },\n            'Africa/Cairo': { offset: 120, dst: null },\n            'Africa/Casablanca': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Africa/Johannesburg': { offset: 120, dst: null },\n            'Africa/Lagos': { offset: 60, dst: null },\n            'Africa/Nairobi': { offset: 180, dst: null },\n\n            // Americas\n            'America/Anchorage': { offset: -540, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Argentina/Buenos_Aires': { offset: -180, dst: null },\n            'America/Bogota': { offset: -300, dst: null },\n            'America/Caracas': { offset: -240, dst: null },\n            'America/Chicago': { offset: -360, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Denver': { offset: -420, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Detroit': { offset: -300, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Halifax': { offset: -240, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Los_Angeles': { offset: -480, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Mexico_City': { offset: -360, dst: { start: { month: 4, week: 1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'America/New_York': { offset: -300, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Phoenix': { offset: -420, dst: null },\n            'America/Regina': { offset: -360, dst: null },\n            'America/Santiago': { offset: -180, dst: { start: { month: 9, week: 1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 60 }},\n            'America/Sao_Paulo': { offset: -180, dst: { start: { month: 10, week: 3, day: 0 }, end: { month: 2, week: 3, day: 0 }, offset: 60 }},\n            'America/St_Johns': { offset: -210, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Toronto': { offset: -300, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'America/Vancouver': { offset: -480, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n\n            // Asia\n            'Asia/Baghdad': { offset: 180, dst: null },\n            'Asia/Bangkok': { offset: 420, dst: null },\n            'Asia/Dubai': { offset: 240, dst: null },\n            'Asia/Hong_Kong': { offset: 480, dst: null },\n            'Asia/Jakarta': { offset: 420, dst: null },\n            'Asia/Jerusalem': { offset: 120, dst: { start: { month: 3, week: -1, day: 5 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Asia/Karachi': { offset: 300, dst: null },\n            'Asia/Kolkata': { offset: 330, dst: null },\n            'Asia/Kuala_Lumpur': { offset: 480, dst: null },\n            'Asia/Manila': { offset: 480, dst: null },\n            'Asia/Seoul': { offset: 540, dst: null },\n            'Asia/Shanghai': { offset: 480, dst: null },\n            'Asia/Singapore': { offset: 480, dst: null },\n            'Asia/Taipei': { offset: 480, dst: null },\n            'Asia/Tehran': { offset: 210, dst: { start: { month: 3, week: 4, day: 0 }, end: { month: 9, week: 4, day: 0 }, offset: 60 }},\n            'Asia/Tokyo': { offset: 540, dst: null },\n\n            // Atlantic\n            'Atlantic/Azores': { offset: -60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Atlantic/Bermuda': { offset: -240, dst: { start: { month: 3, week: 2, day: 0 }, end: { month: 11, week: 1, day: 0 }, offset: 60 }},\n            'Atlantic/Reykjavik': { offset: 0, dst: null },\n\n            // Australia & Pacific\n            'Australia/Adelaide': { offset: 570, dst: { start: { month: 10, week: 1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 60 }},\n            'Australia/Brisbane': { offset: 600, dst: null },\n            'Australia/Darwin': { offset: 570, dst: null },\n            'Australia/Hobart': { offset: 600, dst: { start: { month: 10, week: 1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 60 }},\n            'Australia/Melbourne': { offset: 600, dst: { start: { month: 10, week: 1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 60 }},\n            'Australia/Perth': { offset: 480, dst: null },\n            'Australia/Sydney': { offset: 600, dst: { start: { month: 10, week: 1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 60 }},\n\n            // Europe\n            'Europe/Amsterdam': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Athens': { offset: 120, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Berlin': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Brussels': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Budapest': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Copenhagen': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Dublin': { offset: 0, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Helsinki': { offset: 120, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Istanbul': { offset: 180, dst: null },\n            'Europe/Kiev': { offset: 120, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Lisbon': { offset: 0, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/London': { offset: 0, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Madrid': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Moscow': { offset: 180, dst: null },\n            'Europe/Oslo': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Paris': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Prague': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Rome': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Stockholm': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Vienna': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Warsaw': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n            'Europe/Zurich': { offset: 60, dst: { start: { month: 3, week: -1, day: 0 }, end: { month: 10, week: -1, day: 0 }, offset: 60 }},\n\n            // Indian\n            'Indian/Maldives': { offset: 300, dst: null },\n            'Indian/Mauritius': { offset: 240, dst: null },\n\n            // Pacific\n            'Pacific/Auckland': { offset: 720, dst: { start: { month: 9, week: -1, day: 0 }, end: { month: 4, week: 1, day: 0 }, offset: 60 }},\n            'Pacific/Fiji': { offset: 720, dst: { start: { month: 11, week: 1, day: 0 }, end: { month: 1, week: 3, day: 0 }, offset: 60 }},\n            'Pacific/Guam': { offset: 600, dst: null },\n            'Pacific/Honolulu': { offset: -600, dst: null },\n            'Pacific/Midway': { offset: -660, dst: null },\n            'Pacific/Noumea': { offset: 660, dst: null },\n            'Pacific/Pago_Pago': { offset: -660, dst: null },\n            'Pacific/Port_Moresby': { offset: 600, dst: null },\n            'Pacific/Tahiti': { offset: -600, dst: null }\n        };\n\n        // Timezone aliases and abbreviations\n        this.aliases = {\n            // Common abbreviations to IANA\n            'EST': 'America/New_York',\n            'EDT': 'America/New_York',\n            'CST': 'America/Chicago',\n            'CDT': 'America/Chicago',\n            'MST': 'America/Denver',\n            'MDT': 'America/Denver',\n            'PST': 'America/Los_Angeles',\n            'PDT': 'America/Los_Angeles',\n            'AKST': 'America/Anchorage',\n            'AKDT': 'America/Anchorage',\n            'HST': 'Pacific/Honolulu',\n            'AST': 'America/Halifax',\n            'ADT': 'America/Halifax',\n            'NST': 'America/St_Johns',\n            'NDT': 'America/St_Johns',\n            'BST': 'Europe/London',\n            'IST': 'Asia/Kolkata',\n            'WET': 'Europe/Lisbon',\n            'WEST': 'Europe/Lisbon',\n            'CET': 'Europe/Paris',\n            'CEST': 'Europe/Paris',\n            'EET': 'Europe/Athens',\n            'EEST': 'Europe/Athens',\n            'MSK': 'Europe/Moscow',\n            'JST': 'Asia/Tokyo',\n            'KST': 'Asia/Seoul',\n            'CST_CN': 'Asia/Shanghai',\n            'HKT': 'Asia/Hong_Kong',\n            'SGT': 'Asia/Singapore',\n            'AEST': 'Australia/Sydney',\n            'AEDT': 'Australia/Sydney',\n            'ACST': 'Australia/Adelaide',\n            'ACDT': 'Australia/Adelaide',\n            'AWST': 'Australia/Perth',\n            'NZST': 'Pacific/Auckland',\n            'NZDT': 'Pacific/Auckland',\n\n            // City/Country aliases\n            'US/Eastern': 'America/New_York',\n            'US/Central': 'America/Chicago',\n            'US/Mountain': 'America/Denver',\n            'US/Pacific': 'America/Los_Angeles',\n            'US/Alaska': 'America/Anchorage',\n            'US/Hawaii': 'Pacific/Honolulu',\n            'Canada/Eastern': 'America/Toronto',\n            'Canada/Central': 'America/Regina',\n            'Canada/Mountain': 'America/Denver',\n            'Canada/Pacific': 'America/Vancouver',\n            'Canada/Atlantic': 'America/Halifax',\n            'Canada/Newfoundland': 'America/St_Johns',\n            'Mexico/General': 'America/Mexico_City',\n            'Brazil/East': 'America/Sao_Paulo',\n            'Chile/Continental': 'America/Santiago',\n            'GB': 'Europe/London',\n            'GB-Eire': 'Europe/London',\n            'Eire': 'Europe/Dublin',\n            'Israel': 'Asia/Jerusalem',\n            'Japan': 'Asia/Tokyo',\n            'Singapore': 'Asia/Singapore',\n            'Hongkong': 'Asia/Hong_Kong',\n            'ROK': 'Asia/Seoul',\n            'PRC': 'Asia/Shanghai',\n            'Australia/NSW': 'Australia/Sydney',\n            'Australia/Victoria': 'Australia/Melbourne',\n            'Australia/Queensland': 'Australia/Brisbane',\n            'Australia/South': 'Australia/Adelaide',\n            'Australia/Tasmania': 'Australia/Hobart',\n            'Australia/West': 'Australia/Perth',\n            'Australia/North': 'Australia/Darwin',\n            'NZ': 'Pacific/Auckland'\n        };\n    }\n\n    /**\n     * Get timezone data by identifier\n     * @param {string} timezone - Timezone identifier or alias\n     * @returns {Object|null} Timezone data or null if not found\n     */\n    getTimezone(timezone) {\n        // Check for alias first\n        if (this.aliases[timezone]) {\n            timezone = this.aliases[timezone];\n        }\n\n        return this.timezones[timezone] || null;\n    }\n\n    /**\n     * Get all available timezone identifiers\n     * @returns {string[]} Array of timezone identifiers\n     */\n    getAllTimezones() {\n        return Object.keys(this.timezones);\n    }\n\n    /**\n     * Check if a timezone identifier is valid\n     * @param {string} timezone - Timezone identifier\n     * @returns {boolean} True if valid\n     */\n    isValidTimezone(timezone) {\n        return this.aliases[timezone] !== undefined || this.timezones[timezone] !== undefined;\n    }\n\n    /**\n     * Resolve timezone alias to canonical identifier\n     * @param {string} timezone - Timezone identifier or alias\n     * @returns {string} Canonical timezone identifier\n     */\n    resolveAlias(timezone) {\n        return this.aliases[timezone] || timezone;\n    }\n\n    /**\n     * Get timezones by offset\n     * @param {number} offsetMinutes - Offset in minutes from UTC\n     * @returns {string[]} Array of timezone identifiers\n     */\n    getTimezonesByOffset(offsetMinutes) {\n        return Object.entries(this.timezones)\n            .filter(([_, data]) => data.offset === offsetMinutes)\n            .map(([id, _]) => id);\n    }\n\n    /**\n     * Get common timezones for quick selection\n     * @returns {Object} Grouped timezones by region\n     */\n    getCommonTimezones() {\n        return {\n            'Americas': [\n                'America/New_York',\n                'America/Chicago',\n                'America/Denver',\n                'America/Los_Angeles',\n                'America/Toronto',\n                'America/Mexico_City',\n                'America/Sao_Paulo'\n            ],\n            'Europe': [\n                'Europe/London',\n                'Europe/Paris',\n                'Europe/Berlin',\n                'Europe/Moscow',\n                'Europe/Rome',\n                'Europe/Madrid',\n                'Europe/Amsterdam'\n            ],\n            'Asia': [\n                'Asia/Tokyo',\n                'Asia/Shanghai',\n                'Asia/Hong_Kong',\n                'Asia/Singapore',\n                'Asia/Kolkata',\n                'Asia/Dubai',\n                'Asia/Seoul'\n            ],\n            'Australia/Pacific': [\n                'Australia/Sydney',\n                'Australia/Melbourne',\n                'Australia/Brisbane',\n                'Australia/Perth',\n                'Pacific/Auckland',\n                'Pacific/Honolulu'\n            ],\n            'Africa': [\n                'Africa/Cairo',\n                'Africa/Lagos',\n                'Africa/Johannesburg',\n                'Africa/Nairobi'\n            ]\n        };\n    }\n}","/**\n * TimezoneManager - Comprehensive timezone handling for global calendar operations\n * Handles timezone conversions, DST transitions, and IANA timezone database\n *\n * Critical for Salesforce orgs spanning multiple timezones\n */\n\nimport { TimezoneDatabase } from './TimezoneDatabase.js';\n\nexport class TimezoneManager {\n    constructor() {\n        // Initialize comprehensive timezone database\n        this.database = new TimezoneDatabase();\n\n        // Cache timezone offsets for performance\n        this.offsetCache = new Map();\n        this.dstCache = new Map();\n\n        // Cache size management\n        this.maxCacheSize = 1000;\n        this.cacheHits = 0;\n        this.cacheMisses = 0;\n    }\n\n    /**\n     * Convert date from one timezone to another\n     * @param {Date} date - Date to convert\n     * @param {string} fromTimezone - Source timezone (IANA identifier)\n     * @param {string} toTimezone - Target timezone (IANA identifier)\n     * @returns {Date} Converted date\n     */\n    convertTimezone(date, fromTimezone, toTimezone) {\n        if (!date) return null;\n        if (fromTimezone === toTimezone) return new Date(date);\n\n        // Get offset difference\n        const fromOffset = this.getTimezoneOffset(date, fromTimezone);\n        const toOffset = this.getTimezoneOffset(date, toTimezone);\n        const offsetDiff = (toOffset - fromOffset) * 60 * 1000; // Convert to milliseconds\n\n        return new Date(date.getTime() + offsetDiff);\n    }\n\n    /**\n     * Convert date to UTC\n     * @param {Date} date - Date in local timezone\n     * @param {string} timezone - Source timezone\n     * @returns {Date} Date in UTC\n     */\n    toUTC(date, timezone) {\n        if (!date) return null;\n        if (timezone === 'UTC') return new Date(date);\n\n        const offset = this.getTimezoneOffset(date, timezone);\n        return new Date(date.getTime() - (offset * 60 * 1000));\n    }\n\n    /**\n     * Convert UTC date to timezone\n     * @param {Date} utcDate - Date in UTC\n     * @param {string} timezone - Target timezone\n     * @returns {Date} Date in specified timezone\n     */\n    fromUTC(utcDate, timezone) {\n        if (!utcDate) return null;\n        if (timezone === 'UTC') return new Date(utcDate);\n\n        const offset = this.getTimezoneOffset(utcDate, timezone);\n        return new Date(utcDate.getTime() + (offset * 60 * 1000));\n    }\n\n    /**\n     * Get timezone offset in minutes\n     * @param {Date} date - Date to check (for DST calculation)\n     * @param {string} timezone - Timezone identifier\n     * @returns {number} Offset in minutes from UTC\n     */\n    getTimezoneOffset(date, timezone) {\n        // Resolve any aliases\n        timezone = this.database.resolveAlias(timezone);\n\n        // Check cache first\n        const cacheKey = `${timezone}_${date.getFullYear()}_${date.getMonth()}_${date.getDate()}`;\n        if (this.offsetCache.has(cacheKey)) {\n            this.cacheHits++;\n            this._manageCacheSize();\n            return this.offsetCache.get(cacheKey);\n        }\n\n        this.cacheMisses++;\n\n        // Try using Intl API if available (best option for browser/Node.js environments)\n        if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {\n            try {\n                const formatter = new Intl.DateTimeFormat('en-US', {\n                    timeZone: timezone,\n                    year: 'numeric',\n                    month: '2-digit',\n                    day: '2-digit',\n                    hour: '2-digit',\n                    minute: '2-digit',\n                    second: '2-digit',\n                    hour12: false\n                });\n\n                // Create same date in target timezone\n                const parts = formatter.formatToParts(date);\n                const tzDate = new Date(\n                    parts.find(p => p.type === 'year').value,\n                    parts.find(p => p.type === 'month').value - 1,\n                    parts.find(p => p.type === 'day').value,\n                    parts.find(p => p.type === 'hour').value,\n                    parts.find(p => p.type === 'minute').value,\n                    parts.find(p => p.type === 'second').value\n                );\n\n                const offset = (tzDate.getTime() - date.getTime()) / (1000 * 60);\n                this.offsetCache.set(cacheKey, -offset);\n                this._manageCacheSize();\n                return -offset;\n            } catch (e) {\n                // Fallback to database calculation\n            }\n        }\n\n        // Fallback: Use timezone database\n        const tzData = this.database.getTimezone(timezone);\n        if (!tzData) {\n            throw new Error(`Unknown timezone: ${timezone}`);\n        }\n\n        let offset = tzData.offset;\n\n        // Apply DST if applicable\n        if (tzData.dst && this.isDST(date, timezone, tzData.dst)) {\n            offset += tzData.dst.offset;\n        }\n\n        this.offsetCache.set(cacheKey, offset);\n        this._manageCacheSize();\n        return offset;\n    }\n\n    /**\n     * Check if date is in DST for given timezone\n     * @param {Date} date - Date to check\n     * @param {string} timezone - Timezone identifier\n     * @param {Object} [dstRule] - DST rule object (optional, will fetch if not provided)\n     * @returns {boolean} True if in DST\n     */\n    isDST(date, timezone, dstRule = null) {\n        // Get DST rule if not provided\n        if (!dstRule) {\n            const tzData = this.database.getTimezone(timezone);\n            if (!tzData || !tzData.dst) return false;\n            dstRule = tzData.dst;\n        }\n\n        const year = date.getFullYear();\n        const dstStart = this.getNthWeekdayOfMonth(year, dstRule.start.month, dstRule.start.week, dstRule.start.day);\n        const dstEnd = this.getNthWeekdayOfMonth(year, dstRule.end.month, dstRule.end.week, dstRule.end.day);\n\n        // Handle Southern Hemisphere (DST crosses year boundary)\n        if (dstStart > dstEnd) {\n            return date >= dstStart || date < dstEnd;\n        }\n\n        return date >= dstStart && date < dstEnd;\n    }\n\n    /**\n     * Get nth weekday of month\n     * @private\n     */\n    getNthWeekdayOfMonth(year, month, week, dayOfWeek) {\n        const date = new Date(year, month, 1);\n        const firstDay = date.getDay();\n\n        let dayOffset = dayOfWeek - firstDay;\n        if (dayOffset < 0) dayOffset += 7;\n\n        if (week > 0) {\n            // Nth occurrence from start\n            date.setDate(1 + dayOffset + (week - 1) * 7);\n        } else {\n            // Nth occurrence from end\n            const lastDay = new Date(year, month + 1, 0).getDate();\n            date.setDate(lastDay);\n            const lastDayOfWeek = date.getDay();\n            let offset = lastDayOfWeek - dayOfWeek;\n            if (offset < 0) offset += 7;\n            date.setDate(lastDay - offset + (week + 1) * 7);\n        }\n\n        return date;\n    }\n\n    /**\n     * Get list of common timezones\n     * @returns {Array<{value: string, label: string, offset: string}>}\n     */\n    getCommonTimezones() {\n        const now = new Date();\n        const timezones = [\n            { value: 'America/New_York', label: 'Eastern Time (New York)', region: 'Americas' },\n            { value: 'America/Chicago', label: 'Central Time (Chicago)', region: 'Americas' },\n            { value: 'America/Denver', label: 'Mountain Time (Denver)', region: 'Americas' },\n            { value: 'America/Phoenix', label: 'Mountain Time - Arizona (Phoenix)', region: 'Americas' },\n            { value: 'America/Los_Angeles', label: 'Pacific Time (Los Angeles)', region: 'Americas' },\n            { value: 'America/Anchorage', label: 'Alaska Time (Anchorage)', region: 'Americas' },\n            { value: 'Pacific/Honolulu', label: 'Hawaii Time (Honolulu)', region: 'Pacific' },\n            { value: 'America/Toronto', label: 'Eastern Time (Toronto)', region: 'Americas' },\n            { value: 'America/Vancouver', label: 'Pacific Time (Vancouver)', region: 'Americas' },\n            { value: 'America/Mexico_City', label: 'Central Time (Mexico City)', region: 'Americas' },\n            { value: 'America/Sao_Paulo', label: 'Brasilia Time (SÃ£o Paulo)', region: 'Americas' },\n            { value: 'Europe/London', label: 'GMT/BST (London)', region: 'Europe' },\n            { value: 'Europe/Paris', label: 'Central European Time (Paris)', region: 'Europe' },\n            { value: 'Europe/Berlin', label: 'Central European Time (Berlin)', region: 'Europe' },\n            { value: 'Europe/Moscow', label: 'Moscow Time', region: 'Europe' },\n            { value: 'Asia/Dubai', label: 'Gulf Time (Dubai)', region: 'Asia' },\n            { value: 'Asia/Kolkata', label: 'India Time (Mumbai)', region: 'Asia' },\n            { value: 'Asia/Shanghai', label: 'China Time (Shanghai)', region: 'Asia' },\n            { value: 'Asia/Tokyo', label: 'Japan Time (Tokyo)', region: 'Asia' },\n            { value: 'Asia/Seoul', label: 'Korea Time (Seoul)', region: 'Asia' },\n            { value: 'Asia/Singapore', label: 'Singapore Time', region: 'Asia' },\n            { value: 'Australia/Sydney', label: 'Australian Eastern Time (Sydney)', region: 'Oceania' },\n            { value: 'Australia/Melbourne', label: 'Australian Eastern Time (Melbourne)', region: 'Oceania' },\n            { value: 'Pacific/Auckland', label: 'New Zealand Time (Auckland)', region: 'Oceania' },\n            { value: 'UTC', label: 'UTC', region: 'UTC' }\n        ];\n\n        // Add current offset to each timezone\n        return timezones.map(tz => {\n            const offset = this.getTimezoneOffset(now, tz.value);\n            const offsetHours = -offset / 60; // Convert to hours from UTC\n            const hours = Math.floor(Math.abs(offsetHours));\n            const minutes = Math.round(Math.abs(offsetHours % 1) * 60);\n            const sign = offsetHours >= 0 ? '+' : '-';\n            const offsetStr = `UTC${sign}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;\n\n            return {\n                ...tz,\n                offset: offsetStr,\n                offsetMinutes: -offset // Store in minutes for sorting\n            };\n        }).sort((a, b) => a.offsetMinutes - b.offsetMinutes);\n    }\n\n    /**\n     * Format date in specific timezone\n     * @param {Date} date - Date to format\n     * @param {string} timezone - Timezone for formatting\n     * @param {Object} options - Formatting options\n     * @returns {string} Formatted date string\n     */\n    formatInTimezone(date, timezone, options = {}) {\n        if (!date) return '';\n\n        const defaultOptions = {\n            year: 'numeric',\n            month: '2-digit',\n            day: '2-digit',\n            hour: '2-digit',\n            minute: '2-digit',\n            hour12: true,\n            timeZone: timezone\n        };\n\n        const formatOptions = { ...defaultOptions, ...options };\n\n        try {\n            return new Intl.DateTimeFormat('en-US', formatOptions).format(date);\n        } catch (e) {\n            // Fallback to basic formatting\n            const tzDate = this.fromUTC(this.toUTC(date, 'UTC'), timezone);\n            return tzDate.toLocaleString('en-US', options);\n        }\n    }\n\n    /**\n     * Get timezone from browser/system\n     * @returns {string} IANA timezone identifier\n     */\n    getSystemTimezone() {\n        if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {\n            try {\n                return Intl.DateTimeFormat().resolvedOptions().timeZone;\n            } catch (e) {\n                // Fallback\n            }\n        }\n\n        // Fallback based on offset\n        const offset = new Date().getTimezoneOffset();\n        const offsetHours = -offset / 60;\n\n        // Try to match offset to known timezone\n        for (const [tz, tzOffset] of Object.entries(this.timezoneOffsets)) {\n            if (tzOffset === offsetHours) {\n                return tz;\n            }\n        }\n\n        return 'UTC';\n    }\n\n    /**\n     * Parse timezone from string (handles abbreviations)\n     * @param {string} tzString - Timezone string\n     * @returns {string} IANA timezone identifier\n     */\n    parseTimezone(tzString) {\n        if (!tzString) return 'UTC';\n\n        // Check if it's already an IANA identifier\n        if (this.timezoneOffsets.hasOwnProperty(tzString)) {\n            return tzString;\n        }\n\n        // Check abbreviations\n        const upperTz = tzString.toUpperCase();\n        if (this.timezoneAbbreviations.hasOwnProperty(upperTz)) {\n            return this.timezoneAbbreviations[upperTz];\n        }\n\n        // Try to parse offset format (e.g., \"+05:30\", \"-08:00\")\n        const offsetMatch = tzString.match(/^([+-])(\\d{2}):?(\\d{2})$/);\n        if (offsetMatch) {\n            const sign = offsetMatch[1] === '+' ? 1 : -1;\n            const hours = parseInt(offsetMatch[2], 10);\n            const minutes = parseInt(offsetMatch[3], 10);\n            const totalOffset = sign * (hours + minutes / 60);\n\n            // Find matching timezone\n            for (const [tz, offset] of Object.entries(this.timezoneOffsets)) {\n                if (offset === totalOffset) {\n                    return tz;\n                }\n            }\n        }\n\n        return 'UTC';\n    }\n\n    /**\n     * Calculate timezone difference in hours\n     * @param {string} timezone1 - First timezone\n     * @param {string} timezone2 - Second timezone\n     * @param {Date} [date] - Date for DST calculation\n     * @returns {number} Hour difference\n     */\n    getTimezoneDifference(timezone1, timezone2, date = new Date()) {\n        const offset1 = this.getTimezoneOffset(date, timezone1);\n        const offset2 = this.getTimezoneOffset(date, timezone2);\n        return (offset2 - offset1) / 60;\n    }\n\n    /**\n     * Clear caches (useful when date changes significantly)\n     */\n    clearCache() {\n        this.offsetCache.clear();\n        this.dstCache.clear();\n        this.cacheHits = 0;\n        this.cacheMisses = 0;\n    }\n\n    /**\n     * Validate timezone identifier\n     * @param {string} timezone - Timezone to validate\n     * @returns {boolean} True if valid\n     */\n    isValidTimezone(timezone) {\n        return this.database.isValidTimezone(timezone);\n    }\n\n    /**\n     * Get cache statistics\n     * @returns {Object} Cache stats\n     */\n    getCacheStats() {\n        const hitRate = this.cacheHits + this.cacheMisses > 0\n            ? (this.cacheHits / (this.cacheHits + this.cacheMisses) * 100).toFixed(2)\n            : 0;\n\n        return {\n            offsetCacheSize: this.offsetCache.size,\n            dstCacheSize: this.dstCache.size,\n            maxCacheSize: this.maxCacheSize,\n            cacheHits: this.cacheHits,\n            cacheMisses: this.cacheMisses,\n            hitRate: `${hitRate}%`\n        };\n    }\n\n    /**\n     * Manage cache size - evict old entries if needed\n     * @private\n     */\n    _manageCacheSize() {\n        // Clear caches if they get too large\n        if (this.offsetCache.size > this.maxCacheSize) {\n            // Remove first half of entries (oldest)\n            const entriesToRemove = Math.floor(this.offsetCache.size / 2);\n            const keys = Array.from(this.offsetCache.keys());\n            for (let i = 0; i < entriesToRemove; i++) {\n                this.offsetCache.delete(keys[i]);\n            }\n        }\n\n        if (this.dstCache.size > this.maxCacheSize / 2) {\n            const entriesToRemove = Math.floor(this.dstCache.size / 2);\n            const keys = Array.from(this.dstCache.keys());\n            for (let i = 0; i < entriesToRemove; i++) {\n                this.dstCache.delete(keys[i]);\n            }\n        }\n    }\n}","/**\n * Event class - represents a calendar event with timezone support\n * Pure JavaScript, no DOM dependencies\n * Locker Service compatible\n */\n\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\nexport class Event {\n  /**\n   * Normalize event data\n   * @param {import('../../types.js').EventData} data - Raw event data\n   * @returns {import('../../types.js').EventData} Normalized event data\n   */\n  static normalize(data) {\n    const normalized = { ...data };\n\n    // Ensure dates are Date objects\n    if (normalized.start && !(normalized.start instanceof Date)) {\n      normalized.start = new Date(normalized.start);\n    }\n    if (normalized.end && !(normalized.end instanceof Date)) {\n      normalized.end = new Date(normalized.end);\n    }\n\n    // If no end date, set it to start date\n    if (!normalized.end) {\n      normalized.end = normalized.start ? new Date(normalized.start) : null;\n    }\n\n    // For all-day events, normalize times to midnight\n    if (normalized.allDay && normalized.start) {\n      normalized.start.setHours(0, 0, 0, 0);\n      if (normalized.end) {\n        normalized.end.setHours(23, 59, 59, 999);\n      }\n    }\n\n    // Normalize string fields\n    normalized.id = String(normalized.id || '').trim();\n    normalized.title = String(normalized.title || '').trim();\n    normalized.description = String(normalized.description || '').trim();\n    normalized.location = String(normalized.location || '').trim();\n\n    // Normalize arrays\n    normalized.attendees = Array.isArray(normalized.attendees) ? normalized.attendees : [];\n    normalized.reminders = Array.isArray(normalized.reminders) ? normalized.reminders : [];\n    normalized.categories = Array.isArray(normalized.categories) ? normalized.categories : [];\n    normalized.attachments = Array.isArray(normalized.attachments) ? normalized.attachments : [];\n\n    // Normalize status and visibility\n    const validStatuses = ['confirmed', 'tentative', 'cancelled'];\n    if (!validStatuses.includes(normalized.status)) {\n      normalized.status = 'confirmed';\n    }\n\n    const validVisibilities = ['public', 'private', 'confidential'];\n    if (!validVisibilities.includes(normalized.visibility)) {\n      normalized.visibility = 'public';\n    }\n\n    // Normalize colors\n    if (normalized.color && !normalized.backgroundColor) {\n      normalized.backgroundColor = normalized.color;\n    }\n    if (normalized.color && !normalized.borderColor) {\n      normalized.borderColor = normalized.color;\n    }\n\n    return normalized;\n  }\n\n  /**\n   * Validate event data\n   * @param {import('../../types.js').EventData} data - Normalized event data\n   * @throws {Error} If validation fails\n   */\n  static validate(data) {\n    // Required fields\n    if (!data.id) {\n      throw new Error('Event must have an id');\n    }\n    if (!data.title) {\n      throw new Error('Event must have a title');\n    }\n    if (!data.start) {\n      throw new Error('Event must have a start date');\n    }\n\n    // Validate dates\n    if (!(data.start instanceof Date) || isNaN(data.start.getTime())) {\n      throw new Error('Invalid start date');\n    }\n    if (data.end && (!(data.end instanceof Date) || isNaN(data.end.getTime()))) {\n      throw new Error('Invalid end date');\n    }\n\n    // Validate date order\n    if (data.end && data.start && data.end < data.start) {\n      throw new Error('Event end time cannot be before start time');\n    }\n\n    // Validate recurrence\n    if (data.recurring && !data.recurrenceRule) {\n      throw new Error('Recurring events must have a recurrence rule');\n    }\n\n    // Validate attendees\n    if (data.attendees && data.attendees.length > 0) {\n      data.attendees.forEach((attendee, index) => {\n        if (!attendee.email || !attendee.name) {\n          throw new Error(`Attendee at index ${index} must have email and name`);\n        }\n        // Validate email format\n        const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n        if (!emailRegex.test(attendee.email)) {\n          throw new Error(`Invalid email for attendee: ${attendee.email}`);\n        }\n      });\n    }\n\n    // Validate reminders\n    if (data.reminders && data.reminders.length > 0) {\n      data.reminders.forEach((reminder, index) => {\n        if (!reminder.method || reminder.minutesBefore == null) {\n          throw new Error(`Reminder at index ${index} must have method and minutesBefore`);\n        }\n        if (reminder.minutesBefore < 0) {\n          throw new Error('Reminder minutesBefore must be non-negative');\n        }\n      });\n    }\n\n    // Validate timezone if provided\n    if (data.timeZone) {\n      try {\n        // Test if timezone is valid by trying to use it\n        new Intl.DateTimeFormat('en-US', { timeZone: data.timeZone });\n      } catch (e) {\n        throw new Error(`Invalid timezone: ${data.timeZone}`);\n      }\n    }\n  }\n\n  /**\n   * Create a new Event instance\n   * @param {import('../../types.js').EventData} eventData - Event data object\n   * @throws {Error} If required fields are missing or invalid\n   */\n  constructor({\n    id,\n    title,\n    start,\n    end,\n    allDay = false,\n    description = '',\n    location = '',\n    color = null,\n    backgroundColor = null,\n    borderColor = null,\n    textColor = null,\n    recurring = false,\n    recurrenceRule = null,\n    timeZone = null,\n    endTimeZone = null,\n    status = 'confirmed',\n    visibility = 'public',\n    organizer = null,\n    attendees = [],\n    reminders = [],\n    categories = [],\n    attachments = [],\n    conferenceData = null,\n    metadata = {}\n  }) {\n    // Normalize and validate input\n    const normalized = Event.normalize({\n      id,\n      title,\n      start,\n      end,\n      allDay,\n      description,\n      location,\n      color,\n      backgroundColor,\n      borderColor,\n      textColor,\n      recurring,\n      recurrenceRule,\n      timeZone,\n      endTimeZone,\n      status,\n      visibility,\n      organizer,\n      attendees,\n      reminders,\n      categories,\n      attachments,\n      conferenceData,\n      metadata\n    });\n\n    // Validate normalized data\n    Event.validate(normalized);\n\n    this.id = normalized.id;\n    this.title = normalized.title;\n\n    // Initialize timezone manager\n    this._timezoneManager = new TimezoneManager();\n\n    // Timezone handling\n    // Store the timezone the event was created in (wall-clock time)\n    this.timeZone = normalized.timeZone || this._timezoneManager.getSystemTimezone();\n    this.endTimeZone = normalized.endTimeZone || this.timeZone; // Different end timezone for flights etc.\n\n    // Store dates as provided (wall-clock time in event timezone)\n    this.start = normalized.start;\n    this.end = normalized.end;\n\n    // Store UTC versions for efficient querying and comparison\n    this.startUTC = this._timezoneManager.toUTC(this.start, this.timeZone);\n    this.endUTC = this._timezoneManager.toUTC(this.end, this.endTimeZone);\n\n    this.allDay = normalized.allDay;\n    this.description = normalized.description;\n    this.location = normalized.location;\n\n    // Styling\n    this.color = normalized.color;\n    this.backgroundColor = normalized.backgroundColor;\n    this.borderColor = normalized.borderColor;\n    this.textColor = normalized.textColor;\n\n    // Recurrence\n    this.recurring = normalized.recurring;\n    this.recurrenceRule = normalized.recurrenceRule;\n\n    // Store original timezone from system if not provided\n    this._originalTimeZone = normalized.timeZone || null;\n\n    // Event status and visibility\n    this.status = normalized.status;\n    this.visibility = normalized.visibility;\n\n    // People\n    this.organizer = normalized.organizer;\n    this.attendees = [...normalized.attendees];\n\n    // Reminders\n    this.reminders = [...normalized.reminders];\n\n    // Categories/Tags\n    this.categories = [...normalized.categories];\n\n    // Attachments\n    this.attachments = [...normalized.attachments];\n\n    // Conference/Virtual meeting\n    this.conferenceData = normalized.conferenceData;\n\n    // Custom metadata for extensibility\n    this.metadata = { ...normalized.metadata };\n\n    // Computed properties cache\n    this._cache = {};\n\n    // Validate complex properties\n    this._validateAttendees();\n    this._validateReminders();\n  }\n\n  /**\n   * Get event duration in milliseconds\n   * @returns {number} Duration in milliseconds\n   */\n  get duration() {\n    if (!this._cache.duration) {\n      // Use UTC times for accurate duration calculation\n      this._cache.duration = this.endUTC.getTime() - this.startUTC.getTime();\n    }\n    return this._cache.duration;\n  }\n\n  /**\n   * Get start date in a specific timezone\n   * @param {string} timezone - Target timezone\n   * @returns {Date} Start date in specified timezone\n   */\n  getStartInTimezone(timezone) {\n    if (timezone === this.timeZone) {\n      return new Date(this.start);\n    }\n    return this._timezoneManager.fromUTC(this.startUTC, timezone);\n  }\n\n  /**\n   * Get end date in a specific timezone\n   * @param {string} timezone - Target timezone\n   * @returns {Date} End date in specified timezone\n   */\n  getEndInTimezone(timezone) {\n    if (timezone === this.endTimeZone) {\n      return new Date(this.end);\n    }\n    return this._timezoneManager.fromUTC(this.endUTC, timezone);\n  }\n\n  /**\n   * Update event times preserving the timezone\n   * @param {Date} start - New start date\n   * @param {Date} end - New end date\n   * @param {string} [timezone] - Timezone for the new dates\n   */\n  updateTimes(start, end, timezone) {\n    const tz = timezone || this.timeZone;\n\n    this.start = start instanceof Date ? start : new Date(start);\n    this.end = end instanceof Date ? end : new Date(end);\n\n    if (timezone) {\n      this.timeZone = timezone;\n      this.endTimeZone = timezone;\n    }\n\n    // Update UTC versions\n    this.startUTC = this._timezoneManager.toUTC(this.start, this.timeZone);\n    this.endUTC = this._timezoneManager.toUTC(this.end, this.endTimeZone);\n\n    // Clear cache\n    this._cache = {};\n\n    // Validate\n    if (this.endUTC < this.startUTC) {\n      throw new Error('Event end time cannot be before start time');\n    }\n  }\n\n  /**\n   * Get event duration in minutes\n   * @returns {number} Duration in minutes\n   */\n  get durationMinutes() {\n    return Math.floor(this.duration / (1000 * 60));\n  }\n\n  /**\n   * Get event duration in hours\n   * @returns {number} Duration in hours\n   */\n  get durationHours() {\n    return this.duration / (1000 * 60 * 60);\n  }\n\n  /**\n   * Check if this is a multi-day event\n   * @returns {boolean} True if event spans multiple days\n   */\n  get isMultiDay() {\n    if (!this._cache.hasOwnProperty('isMultiDay')) {\n      const startDay = this.start.toDateString();\n      const endDay = this.end.toDateString();\n      this._cache.isMultiDay = startDay !== endDay;\n    }\n    return this._cache.isMultiDay;\n  }\n\n  /**\n   * Check if event is recurring\n   * @returns {boolean} True if event is recurring\n   */\n  isRecurring() {\n    return this.recurring && this.recurrenceRule !== null;\n  }\n\n  /**\n   * Check if event occurs on a specific date\n   * @param {Date|string} date - The date to check\n   * @returns {boolean} True if event occurs on the given date\n   */\n  occursOn(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n\n    const dateString = date.toDateString();\n    const startString = this.start.toDateString();\n    const endString = this.end.toDateString();\n\n    // For all-day events, check if date falls within range\n    if (this.allDay) {\n      return date >= new Date(startString) && date <= new Date(endString);\n    }\n\n    // For timed events, check if any part of the event occurs on this date\n    if (this.isMultiDay) {\n      // Multi-day event: check if date is within range\n      const dayStart = new Date(dateString);\n      const dayEnd = new Date(dateString);\n      dayEnd.setHours(23, 59, 59, 999);\n\n      return this.start <= dayEnd && this.end >= dayStart;\n    } else {\n      // Single day event: check if it's on the same day\n      return startString === dateString;\n    }\n  }\n\n  /**\n   * Check if this event overlaps with another event\n   * @param {Event|{start: Date, end: Date}} otherEvent - The other event or time range to check\n   * @returns {boolean} True if events overlap\n   * @throws {Error} If otherEvent is not an Event instance or doesn't have start/end\n   */\n  overlaps(otherEvent) {\n    if (otherEvent instanceof Event) {\n      // Events don't overlap if one ends before the other starts\n      return !(this.end <= otherEvent.start || this.start >= otherEvent.end);\n    } else if (otherEvent && otherEvent.start && otherEvent.end) {\n      // Allow checking against time ranges\n      return !(this.end <= otherEvent.start || this.start >= otherEvent.end);\n    } else {\n      throw new Error('Parameter must be an Event instance or have start/end properties');\n    }\n  }\n\n  /**\n   * Check if event contains a specific datetime\n   * @param {Date|string} datetime - The datetime to check\n   * @returns {boolean} True if the datetime falls within the event\n   */\n  contains(datetime) {\n    if (!(datetime instanceof Date)) {\n      datetime = new Date(datetime);\n    }\n    return datetime >= this.start && datetime <= this.end;\n  }\n\n  /**\n   * Clone the event with optional updates\n   * @param {Partial<import('../../types.js').EventData>} [updates={}] - Properties to update in the clone\n   * @returns {Event} New Event instance with updated properties\n   */\n  clone(updates = {}) {\n    return new Event({\n      id: this.id,\n      title: this.title,\n      start: new Date(this.start),\n      end: new Date(this.end),\n      allDay: this.allDay,\n      description: this.description,\n      location: this.location,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      textColor: this.textColor,\n      recurring: this.recurring,\n      recurrenceRule: this.recurrenceRule,\n      timeZone: this.timeZone,\n      status: this.status,\n      visibility: this.visibility,\n      organizer: this.organizer ? { ...this.organizer } : null,\n      attendees: this.attendees.map(a => ({ ...a })),\n      reminders: this.reminders.map(r => ({ ...r })),\n      categories: [...this.categories],\n      attachments: this.attachments.map(a => ({ ...a })),\n      conferenceData: this.conferenceData ? { ...this.conferenceData } : null,\n      metadata: { ...this.metadata },\n      ...updates\n    });\n  }\n\n  /**\n   * Convert event to plain object\n   * @returns {import('../../types.js').EventData} Plain object representation of the event\n   */\n  toObject() {\n    return {\n      id: this.id,\n      title: this.title,\n      start: this.start.toISOString(),\n      end: this.end.toISOString(),\n      allDay: this.allDay,\n      description: this.description,\n      location: this.location,\n      color: this.color,\n      backgroundColor: this.backgroundColor,\n      borderColor: this.borderColor,\n      textColor: this.textColor,\n      recurring: this.recurring,\n      recurrenceRule: this.recurrenceRule,\n      timeZone: this.timeZone,\n      status: this.status,\n      visibility: this.visibility,\n      organizer: this.organizer,\n      attendees: this.attendees,\n      reminders: this.reminders,\n      categories: this.categories,\n      attachments: this.attachments,\n      conferenceData: this.conferenceData,\n      metadata: { ...this.metadata }\n    };\n  }\n\n  /**\n   * Create Event from plain object\n   * @param {import('../../types.js').EventData} obj - Plain object with event properties\n   * @returns {Event} New Event instance\n   */\n  static fromObject(obj) {\n    return new Event(obj);\n  }\n\n  /**\n   * Compare events for equality\n   * @param {Event} other - The other event\n   * @returns {boolean} True if events are equal\n   */\n  equals(other) {\n    if (!(other instanceof Event)) return false;\n\n    return (\n      this.id === other.id &&\n      this.title === other.title &&\n      this.start.getTime() === other.start.getTime() &&\n      this.end.getTime() === other.end.getTime() &&\n      this.allDay === other.allDay &&\n      this.description === other.description &&\n      this.location === other.location &&\n      this.recurring === other.recurring &&\n      this.recurrenceRule === other.recurrenceRule &&\n      this.status === other.status\n    );\n  }\n\n  // ============ Attendee Management Methods ============\n\n  /**\n   * Add an attendee to the event\n   * @param {import('../../types.js').Attendee} attendee - Attendee to add\n   * @returns {boolean} True if attendee was added, false if already exists\n   */\n  addAttendee(attendee) {\n    if (!attendee || !attendee.email) {\n      throw new Error('Attendee must have an email');\n    }\n\n    // Check if attendee already exists\n    if (this.hasAttendee(attendee.email)) {\n      return false;\n    }\n\n    // Generate ID if not provided\n    if (!attendee.id) {\n      attendee.id = `attendee_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    // Set defaults\n    attendee.responseStatus = attendee.responseStatus || 'needs-action';\n    attendee.role = attendee.role || 'required';\n\n    this.attendees.push(attendee);\n    return true;\n  }\n\n  /**\n   * Remove an attendee from the event\n   * @param {string} emailOrId - Email or ID of the attendee to remove\n   * @returns {boolean} True if attendee was removed\n   */\n  removeAttendee(emailOrId) {\n    const index = this.attendees.findIndex(\n      a => a.email === emailOrId || a.id === emailOrId\n    );\n\n    if (index !== -1) {\n      this.attendees.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Update an attendee's response status\n   * @param {string} email - Attendee's email\n   * @param {import('../../types.js').AttendeeResponseStatus} responseStatus - New response status\n   * @returns {boolean} True if attendee was updated\n   */\n  updateAttendeeResponse(email, responseStatus) {\n    const attendee = this.getAttendee(email);\n    if (attendee) {\n      attendee.responseStatus = responseStatus;\n      attendee.responseTime = new Date();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get an attendee by email\n   * @param {string} email - Attendee's email\n   * @returns {import('../../types.js').Attendee|null} The attendee or null\n   */\n  getAttendee(email) {\n    return this.attendees.find(a => a.email === email) || null;\n  }\n\n  /**\n   * Check if an attendee exists\n   * @param {string} email - Attendee's email\n   * @returns {boolean} True if attendee exists\n   */\n  hasAttendee(email) {\n    return this.attendees.some(a => a.email === email);\n  }\n\n  /**\n   * Get attendees by response status\n   * @param {import('../../types.js').AttendeeResponseStatus} status - Response status to filter by\n   * @returns {import('../../types.js').Attendee[]} Filtered attendees\n   */\n  getAttendeesByStatus(status) {\n    return this.attendees.filter(a => a.responseStatus === status);\n  }\n\n  /**\n   * Get count of attendees by response status\n   * @returns {Object.<string, number>} Count by status\n   */\n  getAttendeeCounts() {\n    return this.attendees.reduce((counts, attendee) => {\n      const status = attendee.responseStatus || 'needs-action';\n      counts[status] = (counts[status] || 0) + 1;\n      return counts;\n    }, {});\n  }\n\n  // ============ Reminder Management Methods ============\n\n  /**\n   * Add a reminder to the event\n   * @param {import('../../types.js').Reminder} reminder - Reminder to add\n   * @returns {boolean} True if reminder was added\n   */\n  addReminder(reminder) {\n    if (!reminder || typeof reminder.minutesBefore !== 'number') {\n      throw new Error('Reminder must have minutesBefore property');\n    }\n\n    // Generate ID if not provided\n    if (!reminder.id) {\n      reminder.id = `reminder_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    // Set defaults\n    reminder.method = reminder.method || 'popup';\n    reminder.enabled = reminder.enabled !== false;\n\n    // Check for duplicate\n    const duplicate = this.reminders.some(\n      r => r.method === reminder.method && r.minutesBefore === reminder.minutesBefore\n    );\n\n    if (duplicate) {\n      return false;\n    }\n\n    this.reminders.push(reminder);\n    return true;\n  }\n\n  /**\n   * Remove a reminder from the event\n   * @param {string} reminderId - ID of the reminder to remove\n   * @returns {boolean} True if reminder was removed\n   */\n  removeReminder(reminderId) {\n    const index = this.reminders.findIndex(r => r.id === reminderId);\n    if (index !== -1) {\n      this.reminders.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Get active reminders\n   * @returns {import('../../types.js').Reminder[]} Active reminders\n   */\n  getActiveReminders() {\n    return this.reminders.filter(r => r.enabled !== false);\n  }\n\n  /**\n   * Get reminder trigger times\n   * @returns {Date[]} Array of dates when reminders should trigger\n   */\n  getReminderTriggerTimes() {\n    return this.getActiveReminders().map(reminder => {\n      const triggerTime = new Date(this.start);\n      triggerTime.setMinutes(triggerTime.getMinutes() - reminder.minutesBefore);\n      return triggerTime;\n    });\n  }\n\n  // ============ Category Management Methods ============\n\n  /**\n   * Add a category to the event\n   * @param {string} category - Category to add\n   * @returns {boolean} True if category was added\n   */\n  addCategory(category) {\n    if (!category || typeof category !== 'string') {\n      throw new Error('Category must be a non-empty string');\n    }\n\n    const normalizedCategory = category.trim().toLowerCase();\n    if (!this.hasCategory(normalizedCategory)) {\n      this.categories.push(normalizedCategory);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Remove a category from the event\n   * @param {string} category - Category to remove\n   * @returns {boolean} True if category was removed\n   */\n  removeCategory(category) {\n    const normalizedCategory = category.trim().toLowerCase();\n    const index = this.categories.findIndex(\n      c => c.toLowerCase() === normalizedCategory\n    );\n\n    if (index !== -1) {\n      this.categories.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Check if event has a specific category\n   * @param {string} category - Category to check\n   * @returns {boolean} True if event has the category\n   */\n  hasCategory(category) {\n    const normalizedCategory = category.trim().toLowerCase();\n    return this.categories.some(c => c.toLowerCase() === normalizedCategory);\n  }\n\n  /**\n   * Check if event has any of the specified categories\n   * @param {string[]} categories - Categories to check\n   * @returns {boolean} True if event has any of the categories\n   */\n  hasAnyCategory(categories) {\n    return categories.some(category => this.hasCategory(category));\n  }\n\n  /**\n   * Check if event has all of the specified categories\n   * @param {string[]} categories - Categories to check\n   * @returns {boolean} True if event has all of the categories\n   */\n  hasAllCategories(categories) {\n    return categories.every(category => this.hasCategory(category));\n  }\n\n  // ============ Validation Methods ============\n\n  /**\n   * Validate attendees\n   * @private\n   * @throws {Error} If attendees are invalid\n   */\n  _validateAttendees() {\n    for (const attendee of this.attendees) {\n      if (!attendee.email) {\n        throw new Error('All attendees must have an email address');\n      }\n      if (!attendee.name) {\n        attendee.name = attendee.email; // Use email as fallback name\n      }\n      if (!this._isValidEmail(attendee.email)) {\n        throw new Error(`Invalid attendee email: ${attendee.email}`);\n      }\n    }\n  }\n\n  /**\n   * Validate reminders\n   * @private\n   * @throws {Error} If reminders are invalid\n   */\n  _validateReminders() {\n    for (const reminder of this.reminders) {\n      if (typeof reminder.minutesBefore !== 'number' || reminder.minutesBefore < 0) {\n        throw new Error('Reminder minutesBefore must be a positive number');\n      }\n\n      const validMethods = ['email', 'popup', 'sms'];\n      if (!validMethods.includes(reminder.method)) {\n        throw new Error(`Invalid reminder method: ${reminder.method}`);\n      }\n    }\n  }\n\n  /**\n   * Validate email address\n   * @private\n   * @param {string} email - Email to validate\n   * @returns {boolean} True if email is valid\n   */\n  _isValidEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  // ============ Enhanced Getters ============\n\n  /**\n   * Check if the event is cancelled\n   * @returns {boolean} True if event is cancelled\n   */\n  get isCancelled() {\n    return this.status === 'cancelled';\n  }\n\n  /**\n   * Check if the event is tentative\n   * @returns {boolean} True if event is tentative\n   */\n  get isTentative() {\n    return this.status === 'tentative';\n  }\n\n  /**\n   * Check if the event is confirmed\n   * @returns {boolean} True if event is confirmed\n   */\n  get isConfirmed() {\n    return this.status === 'confirmed';\n  }\n\n  /**\n   * Check if the event is private\n   * @returns {boolean} True if event is private\n   */\n  get isPrivate() {\n    return this.visibility === 'private';\n  }\n\n  /**\n   * Check if the event is public\n   * @returns {boolean} True if event is public\n   */\n  get isPublic() {\n    return this.visibility === 'public';\n  }\n\n  /**\n   * Check if the event has attendees\n   * @returns {boolean} True if event has attendees\n   */\n  get hasAttendees() {\n    return this.attendees.length > 0;\n  }\n\n  /**\n   * Check if the event has reminders\n   * @returns {boolean} True if event has reminders\n   */\n  get hasReminders() {\n    return this.reminders.length > 0;\n  }\n\n  /**\n   * Check if the event is a meeting (has attendees or conference data)\n   * @returns {boolean} True if event is a meeting\n   */\n  get isMeeting() {\n    return this.hasAttendees || this.conferenceData !== null;\n  }\n\n  /**\n   * Check if the event is virtual (has conference data)\n   * @returns {boolean} True if event is virtual\n   */\n  get isVirtual() {\n    return this.conferenceData !== null;\n  }\n}","/**\n * DateUtils - Date manipulation utilities\n * Pure functions, no external dependencies\n * Locker Service compatible\n */\nexport class DateUtils {\n  /**\n   * Get the start of a day\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfDay(date) {\n    const result = new Date(date);\n    result.setHours(0, 0, 0, 0);\n    return result;\n  }\n\n  /**\n   * Get the end of a day\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfDay(date) {\n    const result = new Date(date);\n    result.setHours(23, 59, 59, 999);\n    return result;\n  }\n\n  /**\n   * Get the start of a week\n   * @param {Date} date - The date\n   * @param {number} [weekStartsOn=0] - 0 = Sunday, 1 = Monday, etc.\n   * @returns {Date} Start of the week\n   */\n  static startOfWeek(date, weekStartsOn = 0) {\n    const result = new Date(date);\n    const day = result.getDay();\n    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;\n\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() - (diff * 24 * 60 * 60 * 1000));\n    result.setHours(0, 0, 0, 0);\n    return result;\n  }\n\n  /**\n   * Get the end of a week\n   * @param {Date} date - The date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {Date}\n   */\n  static endOfWeek(date, weekStartsOn = 0) {\n    const result = DateUtils.startOfWeek(date, weekStartsOn);\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() + (6 * 24 * 60 * 60 * 1000));\n    result.setHours(23, 59, 59, 999);\n    return result;\n  }\n\n  /**\n   * Get the start of a month\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);\n  }\n\n  /**\n   * Get the end of a month\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0, 23, 59, 59, 999);\n  }\n\n  /**\n   * Get the start of a year\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static startOfYear(date) {\n    return new Date(date.getFullYear(), 0, 1, 0, 0, 0, 0);\n  }\n\n  /**\n   * Get the end of a year\n   * @param {Date} date - The date\n   * @returns {Date}\n   */\n  static endOfYear(date) {\n    return new Date(date.getFullYear(), 11, 31, 23, 59, 59, 999);\n  }\n\n  /**\n   * Add days to a date\n   * @param {Date} date - The date\n   * @param {number} days - Number of days to add (can be negative)\n   * @returns {Date}\n   */\n  static addDays(date, days) {\n    const result = new Date(date);\n    // Use setTime to handle month/year boundaries correctly\n    result.setTime(result.getTime() + (days * 24 * 60 * 60 * 1000));\n    return result;\n  }\n\n  /**\n   * Add weeks to a date\n   * @param {Date} date - The date\n   * @param {number} weeks - Number of weeks to add\n   * @returns {Date}\n   */\n  static addWeeks(date, weeks) {\n    return DateUtils.addDays(date, weeks * 7);\n  }\n\n  /**\n   * Add months to a date\n   * @param {Date} date - The date\n   * @param {number} months - Number of months to add\n   * @returns {Date}\n   */\n  static addMonths(date, months) {\n    const result = new Date(date);\n    const dayOfMonth = result.getDate();\n    result.setMonth(result.getMonth() + months);\n\n    // Handle edge case where day doesn't exist in new month\n    if (result.getDate() !== dayOfMonth) {\n      result.setDate(0); // Go to last day of previous month\n    }\n\n    return result;\n  }\n\n  /**\n   * Add years to a date\n   * @param {Date} date - The date\n   * @param {number} years - Number of years to add\n   * @returns {Date}\n   */\n  static addYears(date, years) {\n    const result = new Date(date);\n    result.setFullYear(result.getFullYear() + years);\n    return result;\n  }\n\n  /**\n   * Get a consistent UTC date string for indexing (YYYY-MM-DD format)\n   * @param {Date} date - The date\n   * @returns {string} UTC date string\n   */\n  static getUTCDateString(date) {\n    const year = date.getUTCFullYear();\n    const month = String(date.getUTCMonth() + 1).padStart(2, '0');\n    const day = String(date.getUTCDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n  }\n\n  /**\n   * Get a consistent local date string for indexing (YYYY-MM-DD format)\n   * @param {Date} date - The date\n   * @returns {string} Local date string\n   */\n  static getLocalDateString(date) {\n    const year = date.getFullYear();\n    const month = String(date.getMonth() + 1).padStart(2, '0');\n    const day = String(date.getDate()).padStart(2, '0');\n    return `${year}-${month}-${day}`;\n  }\n\n  /**\n   * Check if a date is today\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isToday(date) {\n    const today = new Date();\n    return date.toDateString() === today.toDateString();\n  }\n\n  /**\n   * Check if a date is in the past\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isPast(date) {\n    return date < new Date();\n  }\n\n  /**\n   * Check if a date is in the future\n   * @param {Date} date - The date to check\n   * @returns {boolean}\n   */\n  static isFuture(date) {\n    return date > new Date();\n  }\n\n  /**\n   * Check if two dates are on the same day\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameDay(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear() &&\n           date1.getMonth() === date2.getMonth() &&\n           date1.getDate() === date2.getDate();\n  }\n\n  /**\n   * Check if two dates are in the same week\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {boolean}\n   */\n  static isSameWeek(date1, date2, weekStartsOn = 0) {\n    const week1Start = DateUtils.startOfWeek(date1, weekStartsOn);\n    const week2Start = DateUtils.startOfWeek(date2, weekStartsOn);\n    return week1Start.toDateString() === week2Start.toDateString();\n  }\n\n  /**\n   * Check if two dates are in the same month\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameMonth(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear() &&\n           date1.getMonth() === date2.getMonth();\n  }\n\n  /**\n   * Check if two dates are in the same year\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {boolean}\n   */\n  static isSameYear(date1, date2) {\n    return date1.getFullYear() === date2.getFullYear();\n  }\n\n  /**\n   * Get the difference in days between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInDays(date1, date2) {\n    const diff = date1.getTime() - date2.getTime();\n    return Math.floor(diff / (1000 * 60 * 60 * 24));\n  }\n\n  /**\n   * Get the difference in weeks between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInWeeks(date1, date2) {\n    return Math.floor(DateUtils.differenceInDays(date1, date2) / 7);\n  }\n\n  /**\n   * Get the difference in months between two dates\n   * @param {Date} date1 - First date\n   * @param {Date} date2 - Second date\n   * @returns {number}\n   */\n  static differenceInMonths(date1, date2) {\n    const yearDiff = date1.getFullYear() - date2.getFullYear();\n    const monthDiff = date1.getMonth() - date2.getMonth();\n    return yearDiff * 12 + monthDiff;\n  }\n\n  /**\n   * Get the week number of a date\n   * @param {Date} date - The date\n   * @returns {number}\n   */\n  static getWeekNumber(date) {\n    const firstDayOfYear = new Date(date.getFullYear(), 0, 1);\n    const pastDaysOfYear = (date - firstDayOfYear) / 86400000;\n    return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);\n  }\n\n  /**\n   * Get the day of week for a date\n   * @param {Date} date - The date\n   * @param {number} weekStartsOn - 0 = Sunday, 1 = Monday, etc.\n   * @returns {number} 0-6 where 0 is the first day of the week\n   */\n  static getDayOfWeek(date, weekStartsOn = 0) {\n    const day = date.getDay();\n    return (day - weekStartsOn + 7) % 7;\n  }\n\n  /**\n   * Get days in a month\n   * @param {Date} date - Any date in the month\n   * @returns {number}\n   */\n  static getDaysInMonth(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();\n  }\n\n  /**\n   * Format a date using Intl.DateTimeFormat\n   * @param {Date} date - The date to format\n   * @param {string} locale - The locale\n   * @param {Object} options - Intl.DateTimeFormat options\n   * @returns {string}\n   */\n  static format(date, locale = 'en-US', options = {}) {\n    return new Intl.DateTimeFormat(locale, options).format(date);\n  }\n\n  /**\n   * Get month name\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {string} format - 'long', 'short', or 'narrow'\n   * @returns {string}\n   */\n  static getMonthName(date, locale = 'en-US', format = 'long') {\n    return DateUtils.format(date, locale, { month: format });\n  }\n\n  /**\n   * Get day name\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {string} format - 'long', 'short', or 'narrow'\n   * @returns {string}\n   */\n  static getDayName(date, locale = 'en-US', format = 'long') {\n    return DateUtils.format(date, locale, { weekday: format });\n  }\n\n  /**\n   * Format time\n   * @param {Date} date - The date\n   * @param {string} locale - The locale\n   * @param {boolean} use24Hour - Use 24-hour format\n   * @returns {string}\n   */\n  static formatTime(date, locale = 'en-US', use24Hour = false) {\n    return DateUtils.format(date, locale, {\n      hour: 'numeric',\n      minute: '2-digit',\n      hour12: !use24Hour\n    });\n  }\n\n  /**\n   * Parse a time string (HH:MM) to hours and minutes\n   * @param {string} timeString - Time string like \"09:30\"\n   * @returns {{hours: number, minutes: number}}\n   */\n  static parseTime(timeString) {\n    const [hours, minutes] = timeString.split(':').map(Number);\n    return { hours, minutes };\n  }\n\n  /**\n   * Set time on a date\n   * @param {Date} date - The date\n   * @param {string} timeString - Time string like \"09:30\"\n   * @returns {Date}\n   */\n  static setTime(date, timeString) {\n    const result = new Date(date);\n    const { hours, minutes } = DateUtils.parseTime(timeString);\n    result.setHours(hours, minutes, 0, 0);\n    return result;\n  }\n\n  /**\n   * Check if a year is a leap year\n   * @param {number} year - The year\n   * @returns {boolean}\n   */\n  static isLeapYear(year) {\n    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);\n  }\n\n  /**\n   * Get an array of dates between start and end\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @returns {Date[]}\n   */\n  static getDateRange(start, end) {\n    const dates = [];\n    const current = new Date(start);\n    const endTime = end.getTime();\n\n    while (current.getTime() <= endTime) {\n      dates.push(new Date(current));\n      // Use setTime to handle month/year boundaries correctly\n      current.setTime(current.getTime() + (24 * 60 * 60 * 1000));\n    }\n\n    return dates;\n  }\n\n  /**\n   * Clone a date\n   * @param {Date} date - The date to clone\n   * @returns {Date}\n   */\n  static clone(date) {\n    return new Date(date);\n  }\n\n  /**\n   * Validate if a value is a valid date\n   * @param {*} value - Value to check\n   * @returns {boolean}\n   */\n  static isValidDate(value) {\n    return value instanceof Date && !isNaN(value.getTime());\n  }\n\n  /**\n   * Convert a date to a specific timezone\n   * @param {Date} date - The date to convert\n   * @param {string} timeZone - IANA timezone string (e.g., 'America/New_York')\n   * @returns {Date} - Date object adjusted for timezone\n   */\n  static toTimeZone(date, timeZone) {\n    // Get the date string in the target timezone\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12: false\n    });\n\n    const parts = formatter.formatToParts(date);\n    const dateObj = {};\n    parts.forEach(part => {\n      if (part.type !== 'literal') {\n        dateObj[part.type] = part.value;\n      }\n    });\n\n    // Create new date in the target timezone\n    return new Date(\n      `${dateObj.year}-${dateObj.month}-${dateObj.day}T${dateObj.hour}:${dateObj.minute}:${dateObj.second}`\n    );\n  }\n\n  /**\n   * Get timezone offset in minutes for a date\n   * @param {Date} date - The date\n   * @param {string} timeZone - IANA timezone string\n   * @returns {number} - Offset in minutes\n   */\n  static getTimezoneOffset(date, timeZone) {\n    const utcDate = new Date(date.toLocaleString('en-US', { timeZone: 'UTC' }));\n    const tzDate = new Date(date.toLocaleString('en-US', { timeZone }));\n    return (utcDate.getTime() - tzDate.getTime()) / 60000;\n  }\n\n  /**\n   * Check if DST is in effect for a date in a timezone\n   * @param {Date} date - The date to check\n   * @param {string} timeZone - IANA timezone string\n   * @returns {boolean}\n   */\n  static isDST(date, timeZone) {\n    const jan = new Date(date.getFullYear(), 0, 1);\n    const jul = new Date(date.getFullYear(), 6, 1);\n    const janOffset = DateUtils.getTimezoneOffset(jan, timeZone);\n    const julOffset = DateUtils.getTimezoneOffset(jul, timeZone);\n    const currentOffset = DateUtils.getTimezoneOffset(date, timeZone);\n\n    return Math.max(janOffset, julOffset) === currentOffset;\n  }\n\n  /**\n   * Add time accounting for DST transitions\n   * @param {Date} date - The date\n   * @param {number} hours - Hours to add\n   * @param {string} timeZone - IANA timezone string\n   * @returns {Date}\n   */\n  static addHoursWithDST(date, hours, timeZone) {\n    const result = new Date(date);\n    const originalOffset = DateUtils.getTimezoneOffset(date, timeZone);\n\n    // Add hours\n    result.setTime(result.getTime() + (hours * 60 * 60 * 1000));\n\n    // Check if DST transition occurred\n    const newOffset = DateUtils.getTimezoneOffset(result, timeZone);\n    if (originalOffset !== newOffset) {\n      // Adjust for DST change\n      const dstAdjustment = (newOffset - originalOffset) * 60000;\n      result.setTime(result.getTime() + dstAdjustment);\n    }\n\n    return result;\n  }\n\n  /**\n   * Create a date in a specific timezone\n   * @param {number} year\n   * @param {number} month - 0-indexed\n   * @param {number} day\n   * @param {number} hour\n   * @param {number} minute\n   * @param {number} second\n   * @param {string} timeZone - IANA timezone string\n   * @returns {Date}\n   */\n  static createInTimeZone(year, month, day, hour = 0, minute = 0, second = 0, timeZone) {\n    // Create date string in ISO format\n    const dateStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;\n    const timeStr = `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`;\n\n    // Use Intl API to get the UTC time for this local time in the timezone\n    const formatter = new Intl.DateTimeFormat('en-US', {\n      timeZone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n      hour: '2-digit',\n      minute: '2-digit',\n      second: '2-digit',\n      hour12: false\n    });\n\n    // Parse the local date in the target timezone\n    const localDate = new Date(`${dateStr}T${timeStr}`);\n\n    // Get offset and adjust\n    const offset = DateUtils.getTimezoneOffset(localDate, timeZone);\n    const utcTime = localDate.getTime() + (offset * 60000);\n\n    return new Date(utcTime);\n  }\n}","/**\n * RRuleParser - Full RFC 5545 compliant RRULE parser\n * Supports all RFC 5545 recurrence rule features\n */\n\nexport class RRuleParser {\n    /**\n     * Parse an RRULE string into a structured rule object\n     * @param {string|Object} rrule - RRULE string or rule object\n     * @returns {Object} Parsed rule object\n     */\n    static parse(rrule) {\n        // If already an object, validate and return\n        if (typeof rrule === 'object') {\n            return this.validateRule(rrule);\n        }\n\n        const rule = {\n            freq: null,\n            interval: 1,\n            count: null,\n            until: null,\n            byDay: [],\n            byWeekNo: [],\n            byMonth: [],\n            byMonthDay: [],\n            byYearDay: [],\n            bySetPos: [],\n            byHour: [],\n            byMinute: [],\n            bySecond: [],\n            wkst: 'MO', // Week start day\n            exceptions: [],\n            tzid: null\n        };\n\n        // Parse RRULE string\n        const parts = rrule.toUpperCase().split(';');\n\n        for (const part of parts) {\n            const [key, value] = part.split('=');\n\n            switch (key) {\n                case 'FREQ':\n                    rule.freq = this.parseFrequency(value);\n                    break;\n\n                case 'INTERVAL':\n                    rule.interval = parseInt(value, 10);\n                    if (rule.interval < 1) rule.interval = 1;\n                    break;\n\n                case 'COUNT':\n                    rule.count = parseInt(value, 10);\n                    break;\n\n                case 'UNTIL':\n                    rule.until = this.parseDateTime(value);\n                    break;\n\n                case 'BYDAY':\n                    rule.byDay = this.parseByDay(value);\n                    break;\n\n                case 'BYWEEKNO':\n                    rule.byWeekNo = this.parseIntList(value);\n                    break;\n\n                case 'BYMONTH':\n                    rule.byMonth = this.parseIntList(value);\n                    break;\n\n                case 'BYMONTHDAY':\n                    rule.byMonthDay = this.parseIntList(value);\n                    break;\n\n                case 'BYYEARDAY':\n                    rule.byYearDay = this.parseIntList(value);\n                    break;\n\n                case 'BYSETPOS':\n                    rule.bySetPos = this.parseIntList(value);\n                    break;\n\n                case 'BYHOUR':\n                    rule.byHour = this.parseIntList(value);\n                    break;\n\n                case 'BYMINUTE':\n                    rule.byMinute = this.parseIntList(value);\n                    break;\n\n                case 'BYSECOND':\n                    rule.bySecond = this.parseIntList(value);\n                    break;\n\n                case 'WKST':\n                    rule.wkst = value;\n                    break;\n\n                case 'EXDATE':\n                    rule.exceptions = this.parseExceptionDates(value);\n                    break;\n\n                case 'TZID':\n                    rule.tzid = value;\n                    break;\n            }\n        }\n\n        return this.validateRule(rule);\n    }\n\n    /**\n     * Parse frequency value\n     * @private\n     */\n    static parseFrequency(freq) {\n        const validFrequencies = ['SECONDLY', 'MINUTELY', 'HOURLY', 'DAILY', 'WEEKLY', 'MONTHLY', 'YEARLY'];\n        return validFrequencies.includes(freq) ? freq : 'DAILY';\n    }\n\n    /**\n     * Parse BYDAY value\n     * @private\n     */\n    static parseByDay(value) {\n        const days = value.split(',');\n        const weekDays = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n        const result = [];\n\n        for (const day of days) {\n            const match = day.match(/^([+-]?\\d*)([A-Z]{2})$/);\n            if (match) {\n                const [_, nth, weekday] = match;\n                if (weekDays.includes(weekday)) {\n                    result.push({\n                        weekday,\n                        nth: nth ? parseInt(nth, 10) : null\n                    });\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Parse comma-separated integer list\n     * @private\n     */\n    static parseIntList(value) {\n        return value.split(',').map(v => parseInt(v.trim(), 10)).filter(v => !isNaN(v));\n    }\n\n    /**\n     * Parse date/datetime value\n     * @private\n     */\n    static parseDateTime(value) {\n        // Handle different date formats\n        // YYYYMMDD\n        if (value.length === 8) {\n            const year = parseInt(value.substr(0, 4), 10);\n            const month = parseInt(value.substr(4, 2), 10) - 1;\n            const day = parseInt(value.substr(6, 2), 10);\n            return new Date(year, month, day);\n        }\n\n        // YYYYMMDDTHHMMSS\n        if (value.length === 15 && value[8] === 'T') {\n            const year = parseInt(value.substr(0, 4), 10);\n            const month = parseInt(value.substr(4, 2), 10) - 1;\n            const day = parseInt(value.substr(6, 2), 10);\n            const hour = parseInt(value.substr(9, 2), 10);\n            const minute = parseInt(value.substr(11, 2), 10);\n            const second = parseInt(value.substr(13, 2), 10);\n            return new Date(year, month, day, hour, minute, second);\n        }\n\n        // YYYYMMDDTHHMMSSZ (UTC)\n        if (value.length === 16 && value[8] === 'T' && value[15] === 'Z') {\n            const year = parseInt(value.substr(0, 4), 10);\n            const month = parseInt(value.substr(4, 2), 10) - 1;\n            const day = parseInt(value.substr(6, 2), 10);\n            const hour = parseInt(value.substr(9, 2), 10);\n            const minute = parseInt(value.substr(11, 2), 10);\n            const second = parseInt(value.substr(13, 2), 10);\n            return new Date(Date.UTC(year, month, day, hour, minute, second));\n        }\n\n        // Try standard date parse as fallback\n        return new Date(value);\n    }\n\n    /**\n     * Parse exception dates\n     * @private\n     */\n    static parseExceptionDates(value) {\n        const dates = value.split(',');\n        return dates.map(date => this.parseDateTime(date.trim()));\n    }\n\n    /**\n     * Validate and normalize rule\n     * @private\n     */\n    static validateRule(rule) {\n        // Ensure frequency is set\n        if (!rule.freq) {\n            rule.freq = 'DAILY';\n        }\n\n        // Cannot have both COUNT and UNTIL\n        if (rule.count && rule.until) {\n            throw new Error('RRULE cannot have both COUNT and UNTIL');\n        }\n\n        // Validate interval\n        if (rule.interval < 1) {\n            rule.interval = 1;\n        }\n\n        // Validate by* arrays\n        const validateArray = (arr, min, max) => {\n            return arr.filter(v => v >= min && v <= max);\n        };\n\n        rule.byMonth = validateArray(rule.byMonth || [], 1, 12);\n        rule.byMonthDay = validateArray(rule.byMonthDay || [], -31, 31).filter(v => v !== 0);\n        rule.byYearDay = validateArray(rule.byYearDay || [], -366, 366).filter(v => v !== 0);\n        rule.byWeekNo = validateArray(rule.byWeekNo || [], -53, 53).filter(v => v !== 0);\n        rule.byHour = validateArray(rule.byHour || [], 0, 23);\n        rule.byMinute = validateArray(rule.byMinute || [], 0, 59);\n        rule.bySecond = validateArray(rule.bySecond || [], 0, 59);\n\n        return rule;\n    }\n\n    /**\n     * Build RRULE string from rule object\n     * @param {Object} rule - Rule object\n     * @returns {string} RRULE string\n     */\n    static buildRRule(rule) {\n        const parts = [];\n\n        // Required frequency\n        parts.push(`FREQ=${rule.freq}`);\n\n        // Optional interval\n        if (rule.interval && rule.interval > 1) {\n            parts.push(`INTERVAL=${rule.interval}`);\n        }\n\n        // Count or until\n        if (rule.count) {\n            parts.push(`COUNT=${rule.count}`);\n        } else if (rule.until) {\n            parts.push(`UNTIL=${this.formatDateTime(rule.until)}`);\n        }\n\n        // By* rules\n        if (rule.byDay && rule.byDay.length > 0) {\n            const dayStr = rule.byDay.map(d => {\n                return d.nth ? `${d.nth}${d.weekday}` : d.weekday;\n            }).join(',');\n            parts.push(`BYDAY=${dayStr}`);\n        }\n\n        if (rule.byMonth && rule.byMonth.length > 0) {\n            parts.push(`BYMONTH=${rule.byMonth.join(',')}`);\n        }\n\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n            parts.push(`BYMONTHDAY=${rule.byMonthDay.join(',')}`);\n        }\n\n        if (rule.byYearDay && rule.byYearDay.length > 0) {\n            parts.push(`BYYEARDAY=${rule.byYearDay.join(',')}`);\n        }\n\n        if (rule.byWeekNo && rule.byWeekNo.length > 0) {\n            parts.push(`BYWEEKNO=${rule.byWeekNo.join(',')}`);\n        }\n\n        if (rule.bySetPos && rule.bySetPos.length > 0) {\n            parts.push(`BYSETPOS=${rule.bySetPos.join(',')}`);\n        }\n\n        if (rule.byHour && rule.byHour.length > 0) {\n            parts.push(`BYHOUR=${rule.byHour.join(',')}`);\n        }\n\n        if (rule.byMinute && rule.byMinute.length > 0) {\n            parts.push(`BYMINUTE=${rule.byMinute.join(',')}`);\n        }\n\n        if (rule.bySecond && rule.bySecond.length > 0) {\n            parts.push(`BYSECOND=${rule.bySecond.join(',')}`);\n        }\n\n        // Week start\n        if (rule.wkst && rule.wkst !== 'MO') {\n            parts.push(`WKST=${rule.wkst}`);\n        }\n\n        return parts.join(';');\n    }\n\n    /**\n     * Format date/datetime for RRULE\n     * @private\n     */\n    static formatDateTime(date) {\n        const year = date.getUTCFullYear();\n        const month = String(date.getUTCMonth() + 1).padStart(2, '0');\n        const day = String(date.getUTCDate()).padStart(2, '0');\n        const hour = String(date.getUTCHours()).padStart(2, '0');\n        const minute = String(date.getUTCMinutes()).padStart(2, '0');\n        const second = String(date.getUTCSeconds()).padStart(2, '0');\n\n        return `${year}${month}${day}T${hour}${minute}${second}Z`;\n    }\n\n    /**\n     * Get human-readable description of rule\n     * @param {Object} rule - Parsed rule object\n     * @returns {string} Human-readable description\n     */\n    static getDescription(rule) {\n        const freqMap = {\n            'SECONDLY': 'second',\n            'MINUTELY': 'minute',\n            'HOURLY': 'hour',\n            'DAILY': 'day',\n            'WEEKLY': 'week',\n            'MONTHLY': 'month',\n            'YEARLY': 'year'\n        };\n\n        const weekdayMap = {\n            'SU': 'Sunday',\n            'MO': 'Monday',\n            'TU': 'Tuesday',\n            'WE': 'Wednesday',\n            'TH': 'Thursday',\n            'FR': 'Friday',\n            'SA': 'Saturday'\n        };\n\n        const nthMap = {\n            1: 'first',\n            2: 'second',\n            3: 'third',\n            4: 'fourth',\n            5: 'fifth',\n            '-1': 'last',\n            '-2': 'second to last'\n        };\n\n        let description = 'Every';\n\n        // Interval\n        if (rule.interval > 1) {\n            description += ` ${rule.interval}`;\n        }\n\n        // Frequency\n        description += ` ${freqMap[rule.freq]}`;\n        if (rule.interval > 1) {\n            description += 's';\n        }\n\n        // By day\n        if (rule.byDay && rule.byDay.length > 0) {\n            if (rule.freq === 'WEEKLY') {\n                const days = rule.byDay.map(d => weekdayMap[d.weekday]).join(', ');\n                description += ` on ${days}`;\n            } else if (rule.freq === 'MONTHLY' || rule.freq === 'YEARLY') {\n                const dayDescs = rule.byDay.map(d => {\n                    if (d.nth) {\n                        return `the ${nthMap[d.nth] || d.nth} ${weekdayMap[d.weekday]}`;\n                    }\n                    return weekdayMap[d.weekday];\n                }).join(', ');\n                description += ` on ${dayDescs}`;\n            }\n        }\n\n        // By month day\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n            const days = rule.byMonthDay.map(d => {\n                if (d < 0) {\n                    return `${Math.abs(d)} day(s) from the end`;\n                }\n                return `day ${d}`;\n            }).join(', ');\n            description += ` on ${days}`;\n        }\n\n        // By month\n        if (rule.byMonth && rule.byMonth.length > 0) {\n            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',\n                              'July', 'August', 'September', 'October', 'November', 'December'];\n            const months = rule.byMonth.map(m => monthNames[m - 1]).join(', ');\n            description += ` in ${months}`;\n        }\n\n        // Count or until\n        if (rule.count) {\n            description += `, ${rule.count} time${rule.count > 1 ? 's' : ''}`;\n        } else if (rule.until) {\n            description += `, until ${rule.until.toLocaleDateString()}`;\n        }\n\n        return description;\n    }\n}","import { DateUtils } from '../calendar/DateUtils.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\nimport { RRuleParser } from './RRuleParser.js';\n\n/**\n * RecurrenceEngine - Handles expansion of recurring events\n * Full support for RFC 5545 (iCalendar) RRULE specification\n */\nexport class RecurrenceEngine {\n  /**\n   * Expand a recurring event into individual occurrences\n   * @param {import('./Event.js').Event} event - The recurring event\n   * @param {Date} rangeStart - Start of the expansion range\n   * @param {Date} rangeEnd - End of the expansion range\n   * @param {number} [maxOccurrences=365] - Maximum number of occurrences to generate\n   * @param {string} [timezone] - Timezone for expansion (important for DST)\n   * @returns {import('../../types.js').EventOccurrence[]} Array of occurrence objects with start/end dates\n   */\n  static expandEvent(event, rangeStart, rangeEnd, maxOccurrences = 365, timezone = null) {\n    if (!event.recurring || !event.recurrenceRule) {\n      return [{ start: event.start, end: event.end, timezone: event.timeZone }];\n    }\n\n    const rule = this.parseRule(event.recurrenceRule);\n    const occurrences = [];\n    const duration = event.end - event.start;\n    const eventTimezone = timezone || event.timeZone || 'UTC';\n    const tzManager = new TimezoneManager();\n\n    // Work in event's timezone for accurate recurrence calculation\n    let currentDate = new Date(event.start);\n    let count = 0;\n\n    // If UNTIL is specified, use it as the range end\n    if (rule.until && rule.until < rangeEnd) {\n      rangeEnd = rule.until;\n    }\n\n    // Track DST transitions for proper timezone handling\n    let lastOffset = tzManager.getTimezoneOffset(currentDate, eventTimezone);\n\n    while (currentDate <= rangeEnd && count < maxOccurrences) {\n      // Check if this occurrence is within the range\n      if (currentDate >= rangeStart) {\n        const occurrenceStart = new Date(currentDate);\n        const occurrenceEnd = new Date(currentDate.getTime() + duration);\n\n        // Handle DST transitions\n        const currentOffset = tzManager.getTimezoneOffset(occurrenceStart, eventTimezone);\n        if (currentOffset !== lastOffset) {\n          // Adjust for DST change\n          const offsetDiff = lastOffset - currentOffset;\n          occurrenceStart.setMinutes(occurrenceStart.getMinutes() + offsetDiff);\n          occurrenceEnd.setMinutes(occurrenceEnd.getMinutes() + offsetDiff);\n        }\n        lastOffset = currentOffset;\n\n        // Apply exceptions if any\n        if (!this.isException(occurrenceStart, rule, event.id)) {\n          occurrences.push({\n            start: occurrenceStart,\n            end: occurrenceEnd,\n            recurringEventId: event.id,\n            timezone: eventTimezone,\n            originalStart: event.start\n          });\n        }\n      }\n\n      // Calculate next occurrence\n      currentDate = this.getNextOccurrence(currentDate, rule, eventTimezone);\n      count++;\n\n      // Check COUNT limit\n      if (rule.count && count >= rule.count) {\n        break;\n      }\n    }\n\n    return occurrences;\n  }\n\n  /**\n   * Parse an RRULE string into a rule object\n   * @param {string|import('../../types.js').RecurrenceRule} ruleString - RRULE string (e.g., \"FREQ=DAILY;INTERVAL=1;COUNT=10\") or rule object\n   * @returns {import('../../types.js').RecurrenceRule} Parsed rule object\n   */\n  static parseRule(ruleString) {\n    // Use the new comprehensive parser\n    return RRuleParser.parse(ruleString);\n  }\n\n  /**\n   * Calculate the next occurrence based on the rule\n   * @param {Date} currentDate - Current occurrence date\n   * @param {Object} rule - Recurrence rule object\n   * @param {string} [timezone] - Timezone for calculation\n   * @returns {Date} Next occurrence date\n   */\n  static getNextOccurrence(currentDate, rule, timezone = 'UTC') {\n    const next = new Date(currentDate);\n\n    switch (rule.freq) {\n      case 'DAILY':\n        next.setDate(next.getDate() + rule.interval);\n        break;\n\n      case 'WEEKLY':\n        if (rule.byDay && rule.byDay.length > 0) {\n          // Find next day that matches byDay\n          next.setDate(next.getDate() + 1);\n          while (!this.matchesByDay(next, rule.byDay)) {\n            next.setDate(next.getDate() + 1);\n          }\n        } else {\n          // Simple weekly recurrence\n          next.setDate(next.getDate() + (7 * rule.interval));\n        }\n        break;\n\n      case 'MONTHLY':\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n          // Specific day(s) of month\n          const currentMonth = next.getMonth();\n          next.setMonth(currentMonth + rule.interval);\n          next.setDate(rule.byMonthDay[0]); // Use first specified day\n        } else if (rule.byDay && rule.byDay.length > 0) {\n          // Specific weekday of month (e.g., \"2nd Tuesday\")\n          next.setMonth(next.getMonth() + rule.interval);\n          this.setToWeekdayOfMonth(next, rule.byDay[0], rule.bySetPos[0] || 1);\n        } else {\n          // Same day of month\n          next.setMonth(next.getMonth() + rule.interval);\n        }\n        break;\n\n      case 'YEARLY':\n        if (rule.byMonth && rule.byMonth.length > 0) {\n          next.setFullYear(next.getFullYear() + rule.interval);\n          next.setMonth(rule.byMonth[0] - 1); // Months are 0-indexed\n        } else {\n          next.setFullYear(next.getFullYear() + rule.interval);\n        }\n        break;\n\n      default:\n        // Unsupported frequency\n        next.setTime(next.getTime() + (24 * 60 * 60 * 1000)); // Daily fallback\n    }\n\n    return next;\n  }\n\n  /**\n   * Check if a date matches the BYDAY rule\n   * @param {Date} date - Date to check\n   * @param {Array<string>} byDay - Array of day codes (e.g., ['MO', 'WE', 'FR'])\n   * @returns {boolean}\n   */\n  static matchesByDay(date, byDay) {\n    const dayMap = {\n      'SU': 0, 'MO': 1, 'TU': 2, 'WE': 3,\n      'TH': 4, 'FR': 5, 'SA': 6\n    };\n\n    const dayOfWeek = date.getDay();\n    return byDay.some(day => {\n      // Handle numbered weekdays (e.g., \"2MO\" for 2nd Monday)\n      const match = day.match(/^(-?\\d+)?([A-Z]{2})$/);\n      if (match) {\n        const weekdayCode = match[2];\n        return dayMap[weekdayCode] === dayOfWeek;\n      }\n      return false;\n    });\n  }\n\n  /**\n   * Set date to specific weekday of month\n   * @param {Date} date - Date to modify\n   * @param {string} weekday - Weekday code (e.g., 'MO', 'TU')\n   * @param {number} position - Position in month (1-5, or -1 for last)\n   */\n  static setToWeekdayOfMonth(date, weekday, position = 1) {\n    const dayMap = {\n      'SU': 0, 'MO': 1, 'TU': 2, 'WE': 3,\n      'TH': 4, 'FR': 5, 'SA': 6\n    };\n\n    // Extract weekday code if it has a number prefix\n    const match = weekday.match(/^(-?\\d+)?([A-Z]{2})$/);\n    const weekdayCode = match ? match[2] : weekday;\n    const targetDay = dayMap[weekdayCode];\n\n    date.setDate(1); // Start at first of month\n\n    // Find first occurrence of the weekday\n    while (date.getDay() !== targetDay) {\n      date.setDate(date.getDate() + 1);\n    }\n\n    // Move to the nth occurrence\n    if (position > 1) {\n      date.setDate(date.getDate() + (7 * (position - 1)));\n    } else if (position === -1) {\n      // Last occurrence of the month\n      const nextMonth = new Date(date);\n      nextMonth.setMonth(nextMonth.getMonth() + 1);\n      nextMonth.setDate(0); // Last day of current month\n\n      while (nextMonth.getDay() !== targetDay) {\n        nextMonth.setDate(nextMonth.getDate() - 1);\n      }\n      date.setTime(nextMonth.getTime());\n    }\n  }\n\n  /**\n   * Check if a date is an exception\n   * @param {Date} date - Date to check\n   * @param {Object} rule - Rule object with exceptions\n   * @param {string} [eventId] - Event ID for better exception tracking\n   * @returns {boolean}\n   */\n  static isException(date, rule, eventId = null) {\n    if (!rule.exceptions || rule.exceptions.length === 0) {\n      return false;\n    }\n\n    // Support both date-only and date-time exceptions\n    const dateStr = date.toDateString();\n    const dateTime = date.getTime();\n\n    return rule.exceptions.some(exDate => {\n      if (typeof exDate === 'object' && exDate.date) {\n        // Enhanced exception format with reason\n        const exceptionDate = exDate.date instanceof Date ? exDate.date : new Date(exDate.date);\n        if (exDate.matchTime) {\n          return Math.abs(exceptionDate.getTime() - dateTime) < 1000; // Within 1 second\n        }\n        return exceptionDate.toDateString() === dateStr;\n      } else {\n        // Simple date exception\n        const exceptionDate = exDate instanceof Date ? exDate : new Date(exDate);\n        return exceptionDate.toDateString() === dateStr;\n      }\n    });\n  }\n\n  /**\n   * Add exception dates to a recurrence rule\n   * @param {Object} rule - Recurrence rule\n   * @param {Date|Date[]} exceptions - Exception date(s) to add\n   * @param {Object} [options] - Options for exception\n   * @returns {Object} Updated rule\n   */\n  static addExceptions(rule, exceptions, options = {}) {\n    if (!rule.exceptions) {\n      rule.exceptions = [];\n    }\n\n    const exceptionArray = Array.isArray(exceptions) ? exceptions : [exceptions];\n\n    exceptionArray.forEach(date => {\n      if (options.reason || options.matchTime) {\n        rule.exceptions.push({\n          date: date,\n          reason: options.reason,\n          matchTime: options.matchTime || false\n        });\n      } else {\n        rule.exceptions.push(date);\n      }\n    });\n\n    return rule;\n  }\n\n  /**\n   * Parse date from RRULE format (YYYYMMDDTHHMMSSZ)\n   * @param {string} dateStr - Date string in RRULE format\n   * @returns {Date}\n   */\n  static parseDate(dateStr) {\n    if (dateStr.length === 8) {\n      // YYYYMMDD\n      const year = parseInt(dateStr.substr(0, 4), 10);\n      const month = parseInt(dateStr.substr(4, 2), 10) - 1;\n      const day = parseInt(dateStr.substr(6, 2), 10);\n      return new Date(year, month, day);\n    } else if (dateStr.length === 15 || dateStr.length === 16) {\n      // YYYYMMDDTHHMMSS[Z]\n      const year = parseInt(dateStr.substr(0, 4), 10);\n      const month = parseInt(dateStr.substr(4, 2), 10) - 1;\n      const day = parseInt(dateStr.substr(6, 2), 10);\n      const hour = parseInt(dateStr.substr(9, 2), 10);\n      const minute = parseInt(dateStr.substr(11, 2), 10);\n      const second = parseInt(dateStr.substr(13, 2), 10);\n\n      if (dateStr.endsWith('Z')) {\n        return new Date(Date.UTC(year, month, day, hour, minute, second));\n      } else {\n        return new Date(year, month, day, hour, minute, second);\n      }\n    }\n\n    // Fallback to standard date parsing\n    return new Date(dateStr);\n  }\n\n  /**\n   * Generate a human-readable description of the recurrence rule\n   * @param {Object|string} rule - Recurrence rule\n   * @returns {string} Human-readable description\n   */\n  static getDescription(rule) {\n    if (typeof rule === 'string') {\n      rule = this.parseRule(rule);\n    }\n\n    let description = '';\n    const interval = rule.interval || 1;\n\n    switch (rule.freq) {\n      case 'DAILY':\n        description = interval === 1 ? 'Daily' : `Every ${interval} days`;\n        break;\n      case 'WEEKLY':\n        description = interval === 1 ? 'Weekly' : `Every ${interval} weeks`;\n        if (rule.byDay && rule.byDay.length > 0) {\n          const days = rule.byDay.map(d => this.getDayName(d)).join(', ');\n          description += ` on ${days}`;\n        }\n        break;\n      case 'MONTHLY':\n        description = interval === 1 ? 'Monthly' : `Every ${interval} months`;\n        if (rule.byMonthDay && rule.byMonthDay.length > 0) {\n          description += ` on day ${rule.byMonthDay.join(', ')}`;\n        }\n        break;\n      case 'YEARLY':\n        description = interval === 1 ? 'Yearly' : `Every ${interval} years`;\n        break;\n    }\n\n    if (rule.count) {\n      description += `, ${rule.count} times`;\n    } else if (rule.until) {\n      description += `, until ${rule.until.toLocaleDateString()}`;\n    }\n\n    return description;\n  }\n\n  /**\n   * Get day name from RRULE day code\n   * @param {string} dayCode - Day code (e.g., 'MO', '2TU')\n   * @returns {string} Day name\n   */\n  static getDayName(dayCode) {\n    const dayNames = {\n      'SU': 'Sunday', 'MO': 'Monday', 'TU': 'Tuesday',\n      'WE': 'Wednesday', 'TH': 'Thursday', 'FR': 'Friday',\n      'SA': 'Saturday'\n    };\n\n    // Extract day code if it has a number prefix\n    const match = dayCode.match(/^(-?\\d+)?([A-Z]{2})$/);\n    const code = match ? match[2] : dayCode;\n    const position = match && match[1] ? parseInt(match[1], 10) : null;\n\n    let name = dayNames[code] || dayCode;\n\n    if (position) {\n      const ordinals = ['', '1st', '2nd', '3rd', '4th', '5th'];\n      const ordinal = position === -1 ? 'Last' : (ordinals[position] || `${position}th`);\n      name = `${ordinal} ${name}`;\n    }\n\n    return name;\n  }\n}","/**\n * LRU (Least Recently Used) Cache implementation\n * Provides O(1) get and put operations\n */\nexport class LRUCache {\n  /**\n   * Create a new LRU Cache\n   * @param {number} capacity - Maximum number of items in cache\n   */\n  constructor(capacity = 100) {\n    this.capacity = capacity;\n    this.cache = new Map();\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  /**\n   * Get a value from the cache\n   * @param {string} key - Cache key\n   * @returns {*} Cached value or undefined\n   */\n  get(key) {\n    if (!this.cache.has(key)) {\n      this.misses++;\n      return undefined;\n    }\n\n    // Move to end (most recently used)\n    const value = this.cache.get(key);\n    this.cache.delete(key);\n    this.cache.set(key, value);\n    this.hits++;\n    return value;\n  }\n\n  /**\n   * Put a value in the cache\n   * @param {string} key - Cache key\n   * @param {*} value - Value to cache\n   */\n  put(key, value) {\n    // Remove if exists to update position\n    if (this.cache.has(key)) {\n      this.cache.delete(key);\n    } else if (this.cache.size >= this.capacity) {\n      // Remove least recently used (first item)\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n      this.evictions++;\n    }\n\n    this.cache.set(key, value);\n  }\n\n  /**\n   * Check if key exists in cache\n   * @param {string} key - Cache key\n   * @returns {boolean} True if key exists\n   */\n  has(key) {\n    return this.cache.has(key);\n  }\n\n  /**\n   * Remove a key from the cache\n   * @param {string} key - Cache key\n   * @returns {boolean} True if key was removed\n   */\n  delete(key) {\n    return this.cache.delete(key);\n  }\n\n  /**\n   * Clear all cached items\n   */\n  clear() {\n    this.cache.clear();\n    this.hits = 0;\n    this.misses = 0;\n    this.evictions = 0;\n  }\n\n  /**\n   * Get cache statistics\n   * @returns {Object} Cache stats\n   */\n  getStats() {\n    const hitRate = this.hits + this.misses > 0\n      ? (this.hits / (this.hits + this.misses) * 100).toFixed(2)\n      : 0;\n\n    return {\n      size: this.cache.size,\n      capacity: this.capacity,\n      hits: this.hits,\n      misses: this.misses,\n      evictions: this.evictions,\n      hitRate: `${hitRate}%`\n    };\n  }\n\n  /**\n   * Get all keys in order (least to most recently used)\n   * @returns {string[]} Array of keys\n   */\n  keys() {\n    return Array.from(this.cache.keys());\n  }\n\n  /**\n   * Get cache size\n   * @returns {number} Number of items in cache\n   */\n  get size() {\n    return this.cache.size;\n  }\n}","/**\n * AdaptiveMemoryManager - Dynamically manages cache sizes based on memory pressure\n * Monitors memory usage and adjusts cache capacity to prevent memory issues\n */\n\nexport class AdaptiveMemoryManager {\n    constructor(config = {}) {\n        this.config = {\n            checkInterval: 30000, // Check memory every 30 seconds\n            memoryThreshold: 0.8, // Start reducing cache at 80% memory usage\n            criticalThreshold: 0.95, // Emergency clear at 95% memory usage\n            minCacheSize: 10, // Minimum cache size to maintain\n            maxCacheSize: 10000, // Maximum cache size allowed\n            adaptiveScaling: true, // Enable/disable adaptive scaling\n            ...config\n        };\n\n        // Cache references\n        this.caches = new Map();\n\n        // Memory statistics\n        this.stats = {\n            adjustments: 0,\n            emergencyClears: 0,\n            lastMemoryUsage: 0,\n            lastCheckTime: null,\n            cacheResizes: []\n        };\n\n        // Start monitoring if enabled\n        this.monitoringInterval = null;\n        if (this.config.adaptiveScaling) {\n            this.startMonitoring();\n        }\n    }\n\n    /**\n     * Register a cache for management\n     * @param {string} name - Cache identifier\n     * @param {Object} cache - Cache instance with size/clear methods\n     * @param {Object} [options] - Cache-specific options\n     */\n    registerCache(name, cache, options = {}) {\n        this.caches.set(name, {\n            cache,\n            priority: options.priority || 1, // Higher priority = less likely to be reduced\n            currentCapacity: options.initialCapacity || 100,\n            minCapacity: options.minCapacity || this.config.minCacheSize,\n            maxCapacity: options.maxCapacity || this.config.maxCacheSize,\n            scaleFactor: options.scaleFactor || 0.5, // How much to reduce on pressure\n            lastAccess: Date.now()\n        });\n    }\n\n    /**\n     * Unregister a cache\n     * @param {string} name - Cache identifier\n     */\n    unregisterCache(name) {\n        this.caches.delete(name);\n    }\n\n    /**\n     * Start memory monitoring\n     */\n    startMonitoring() {\n        if (this.monitoringInterval) {\n            return;\n        }\n\n        this.monitoringInterval = setInterval(() => {\n            this.checkMemoryPressure();\n        }, this.config.checkInterval);\n\n        // Initial check\n        this.checkMemoryPressure();\n    }\n\n    /**\n     * Stop memory monitoring\n     */\n    stopMonitoring() {\n        if (this.monitoringInterval) {\n            clearInterval(this.monitoringInterval);\n            this.monitoringInterval = null;\n        }\n    }\n\n    /**\n     * Check memory pressure and adjust caches\n     */\n    async checkMemoryPressure() {\n        const memoryUsage = await this.getMemoryUsage();\n        this.stats.lastMemoryUsage = memoryUsage;\n        this.stats.lastCheckTime = new Date();\n\n        if (memoryUsage > this.config.criticalThreshold) {\n            // Emergency clear - clear all caches\n            this.emergencyClear();\n        } else if (memoryUsage > this.config.memoryThreshold) {\n            // Memory pressure - reduce cache sizes\n            this.reduceCacheSizes(memoryUsage);\n        } else if (memoryUsage < this.config.memoryThreshold - 0.2) {\n            // Memory available - can increase cache sizes\n            this.increaseCacheSizes();\n        }\n    }\n\n    /**\n     * Get current memory usage percentage\n     * @returns {Promise<number>} Memory usage as percentage (0-1)\n     */\n    async getMemoryUsage() {\n        // Browser environment\n        if (typeof performance !== 'undefined' && performance.memory) {\n            const memInfo = performance.memory;\n            if (memInfo.jsHeapSizeLimit && memInfo.usedJSHeapSize) {\n                return memInfo.usedJSHeapSize / memInfo.jsHeapSizeLimit;\n            }\n        }\n\n        // Node.js environment\n        if (typeof process !== 'undefined' && process.memoryUsage) {\n            const usage = process.memoryUsage();\n            // Use heap total as the limit in Node.js\n            return usage.heapUsed / usage.heapTotal;\n        }\n\n        // Fallback - estimate based on cache sizes\n        return this.estimateMemoryUsage();\n    }\n\n    /**\n     * Estimate memory usage based on cache sizes\n     * @private\n     */\n    estimateMemoryUsage() {\n        let totalItems = 0;\n        let maxItems = 0;\n\n        for (const [_, cacheInfo] of this.caches) {\n            if (cacheInfo.cache.size !== undefined) {\n                totalItems += cacheInfo.cache.size;\n                maxItems += cacheInfo.maxCapacity;\n            }\n        }\n\n        return maxItems > 0 ? totalItems / maxItems : 0.5;\n    }\n\n    /**\n     * Reduce cache sizes based on memory pressure\n     * @param {number} memoryUsage - Current memory usage percentage\n     */\n    reduceCacheSizes(memoryUsage) {\n        const pressureLevel = (memoryUsage - this.config.memoryThreshold) /\n                            (this.config.criticalThreshold - this.config.memoryThreshold);\n\n        // Sort caches by priority (lower priority first)\n        const sortedCaches = Array.from(this.caches.entries())\n            .sort((a, b) => a[1].priority - b[1].priority);\n\n        for (const [name, cacheInfo] of sortedCaches) {\n            const reduction = Math.floor(cacheInfo.currentCapacity * cacheInfo.scaleFactor * pressureLevel);\n            const newCapacity = Math.max(\n                cacheInfo.minCapacity,\n                cacheInfo.currentCapacity - reduction\n            );\n\n            if (newCapacity < cacheInfo.currentCapacity) {\n                this.resizeCache(name, cacheInfo, newCapacity);\n            }\n        }\n\n        this.stats.adjustments++;\n    }\n\n    /**\n     * Increase cache sizes when memory is available\n     */\n    increaseCacheSizes() {\n        for (const [name, cacheInfo] of this.caches) {\n            // Only increase if cache is being actively used\n            const timeSinceAccess = Date.now() - cacheInfo.lastAccess;\n            if (timeSinceAccess < 60000) { // Used in last minute\n                const increase = Math.floor(cacheInfo.currentCapacity * 0.2);\n                const newCapacity = Math.min(\n                    cacheInfo.maxCapacity,\n                    cacheInfo.currentCapacity + increase\n                );\n\n                if (newCapacity > cacheInfo.currentCapacity) {\n                    this.resizeCache(name, cacheInfo, newCapacity);\n                }\n            }\n        }\n    }\n\n    /**\n     * Resize a cache\n     * @private\n     */\n    resizeCache(name, cacheInfo, newCapacity) {\n        const oldCapacity = cacheInfo.currentCapacity;\n        cacheInfo.currentCapacity = newCapacity;\n\n        // If cache has a capacity property, update it\n        if (cacheInfo.cache.capacity !== undefined) {\n            cacheInfo.cache.capacity = newCapacity;\n        }\n\n        // If cache is now over capacity, evict excess items\n        if (cacheInfo.cache.size > newCapacity) {\n            this.evictExcessItems(cacheInfo.cache, newCapacity);\n        }\n\n        // Record resize event\n        this.stats.cacheResizes.push({\n            cache: name,\n            timestamp: new Date(),\n            oldCapacity,\n            newCapacity,\n            reason: newCapacity < oldCapacity ? 'pressure' : 'available'\n        });\n\n        // Keep only last 100 resize events\n        if (this.stats.cacheResizes.length > 100) {\n            this.stats.cacheResizes.shift();\n        }\n    }\n\n    /**\n     * Evict excess items from cache\n     * @private\n     */\n    evictExcessItems(cache, targetSize) {\n        if (cache.size <= targetSize) {\n            return;\n        }\n\n        const itemsToRemove = cache.size - targetSize;\n\n        // If cache is a Map or has keys method\n        if (cache.keys) {\n            const keys = Array.from(cache.keys());\n            for (let i = 0; i < itemsToRemove; i++) {\n                cache.delete(keys[i]);\n            }\n        } else if (cache.clear) {\n            // Last resort - clear the cache\n            cache.clear();\n        }\n    }\n\n    /**\n     * Emergency clear all caches\n     */\n    emergencyClear() {\n        for (const [name, cacheInfo] of this.caches) {\n            if (cacheInfo.cache.clear) {\n                cacheInfo.cache.clear();\n            }\n            // Reset to minimum capacity\n            cacheInfo.currentCapacity = cacheInfo.minCapacity;\n        }\n\n        this.stats.emergencyClears++;\n        console.warn('AdaptiveMemoryManager: Emergency cache clear triggered');\n    }\n\n    /**\n     * Update cache access time\n     * @param {string} name - Cache name\n     */\n    touchCache(name) {\n        const cacheInfo = this.caches.get(name);\n        if (cacheInfo) {\n            cacheInfo.lastAccess = Date.now();\n        }\n    }\n\n    /**\n     * Get memory management statistics\n     * @returns {Object} Statistics object\n     */\n    getStats() {\n        const cacheStats = {};\n        for (const [name, cacheInfo] of this.caches) {\n            cacheStats[name] = {\n                size: cacheInfo.cache.size || 0,\n                capacity: cacheInfo.currentCapacity,\n                priority: cacheInfo.priority,\n                lastAccess: new Date(cacheInfo.lastAccess)\n            };\n        }\n\n        return {\n            ...this.stats,\n            memoryUsagePercent: `${(this.stats.lastMemoryUsage * 100).toFixed(2)}%`,\n            totalCaches: this.caches.size,\n            cacheStats,\n            monitoring: this.monitoringInterval !== null\n        };\n    }\n\n    /**\n     * Manual trigger for memory pressure check\n     */\n    async checkNow() {\n        await this.checkMemoryPressure();\n    }\n\n    /**\n     * Set memory thresholds\n     * @param {Object} thresholds - New threshold values\n     */\n    setThresholds(thresholds) {\n        if (thresholds.memoryThreshold !== undefined) {\n            this.config.memoryThreshold = Math.max(0.5, Math.min(0.95, thresholds.memoryThreshold));\n        }\n        if (thresholds.criticalThreshold !== undefined) {\n            this.config.criticalThreshold = Math.max(this.config.memoryThreshold + 0.05, Math.min(1.0, thresholds.criticalThreshold));\n        }\n    }\n\n    /**\n     * Destroy manager and clean up\n     */\n    destroy() {\n        this.stopMonitoring();\n        this.caches.clear();\n    }\n}","/**\n * PerformanceOptimizer - Optimizes calendar operations for large datasets\n * Includes caching, lazy loading, and batch processing with adaptive memory management\n */\n\nimport { LRUCache } from './LRUCache.js';\nimport { AdaptiveMemoryManager } from './AdaptiveMemoryManager.js';\n\nexport class PerformanceOptimizer {\n  constructor(config = {}) {\n    // Configuration\n    this.config = {\n      enableCache: true,\n      cacheCapacity: 500,\n      maxIndexDays: 365,\n      batchSize: 100,\n      enableMetrics: true,\n      cleanupInterval: 3600000, // 1 hour in ms\n      maxIndexAge: 30 * 24 * 60 * 60 * 1000, // 30 days in ms\n      enableAdaptiveMemory: true, // Enable adaptive memory management\n      ...config\n    };\n\n    // Caches with initial capacities\n    this.eventCache = new LRUCache(this.config.cacheCapacity);\n    this.queryCache = new LRUCache(Math.floor(this.config.cacheCapacity / 2));\n    this.dateRangeCache = new LRUCache(Math.floor(this.config.cacheCapacity / 4));\n\n    // Adaptive memory manager\n    if (this.config.enableAdaptiveMemory) {\n      this.memoryManager = new AdaptiveMemoryManager({\n        checkInterval: 30000,\n        memoryThreshold: 0.75,\n        criticalThreshold: 0.90\n      });\n\n      // Register caches with memory manager\n      this.memoryManager.registerCache('events', this.eventCache, {\n        priority: 3, // Highest priority\n        initialCapacity: this.config.cacheCapacity,\n        minCapacity: 50,\n        maxCapacity: 2000\n      });\n\n      this.memoryManager.registerCache('queries', this.queryCache, {\n        priority: 2,\n        initialCapacity: Math.floor(this.config.cacheCapacity / 2),\n        minCapacity: 25,\n        maxCapacity: 1000\n      });\n\n      this.memoryManager.registerCache('dateRanges', this.dateRangeCache, {\n        priority: 1,\n        initialCapacity: Math.floor(this.config.cacheCapacity / 4),\n        minCapacity: 10,\n        maxCapacity: 500\n      });\n    }\n\n    // Lazy loading tracking\n    this.lazyIndexes = new Map(); // eventId -> Set of date strings\n    this.pendingIndexes = new Map(); // eventId -> Promise\n\n    // Batch processing\n    this.batchQueue = [];\n    this.batchTimer = null;\n    this.batchCallbacks = [];\n\n    // Performance metrics\n    this.metrics = {\n      operations: {},\n      averageTimes: {},\n      slowQueries: []\n    };\n\n    // Cleanup timer\n    this.cleanupTimer = null;\n    if (this.config.cleanupInterval > 0) {\n      this.startCleanupTimer();\n    }\n  }\n\n  /**\n   * Measure operation performance\n   * @param {string} operation - Operation name\n   * @param {Function} fn - Function to measure\n   * @returns {*} Function result\n   */\n  measure(operation, fn) {\n    if (!this.config.enableMetrics) {\n      return fn();\n    }\n\n    const start = performance.now();\n    try {\n      const result = fn();\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Measure async operation performance\n   * @param {string} operation - Operation name\n   * @param {Function} fn - Async function to measure\n   * @returns {Promise<*>} Function result\n   */\n  async measureAsync(operation, fn) {\n    if (!this.config.enableMetrics) {\n      return await fn();\n    }\n\n    const start = performance.now();\n    try {\n      const result = await fn();\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration);\n      return result;\n    } catch (error) {\n      const duration = performance.now() - start;\n      this.recordMetric(operation, duration, true);\n      throw error;\n    }\n  }\n\n  /**\n   * Record performance metric\n   * @private\n   */\n  recordMetric(operation, duration, isError = false) {\n    if (!this.metrics.operations[operation]) {\n      this.metrics.operations[operation] = {\n        count: 0,\n        totalTime: 0,\n        errors: 0,\n        min: Infinity,\n        max: 0\n      };\n    }\n\n    const metric = this.metrics.operations[operation];\n    metric.count++;\n    metric.totalTime += duration;\n    metric.min = Math.min(metric.min, duration);\n    metric.max = Math.max(metric.max, duration);\n\n    if (isError) {\n      metric.errors++;\n    }\n\n    // Update average\n    this.metrics.averageTimes[operation] = metric.totalTime / metric.count;\n\n    // Track slow queries\n    if (duration > 100) {\n      this.metrics.slowQueries.push({\n        operation,\n        duration,\n        timestamp: new Date(),\n        isError\n      });\n\n      // Keep only last 100 slow queries\n      if (this.metrics.slowQueries.length > 100) {\n        this.metrics.slowQueries.shift();\n      }\n    }\n  }\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Performance metrics\n   */\n  getMetrics() {\n    const summary = {\n      cacheStats: {\n        event: this.eventCache.getStats(),\n        query: this.queryCache.getStats(),\n        dateRange: this.dateRangeCache.getStats()\n      },\n      operations: {},\n      slowestOperations: [],\n      recentSlowQueries: this.metrics.slowQueries.slice(-10),\n      memoryManagement: this.memoryManager ? this.memoryManager.getStats() : null\n    };\n\n    // Process operations\n    for (const [op, data] of Object.entries(this.metrics.operations)) {\n      summary.operations[op] = {\n        count: data.count,\n        avgTime: `${(data.totalTime / data.count).toFixed(2)}ms`,\n        minTime: `${data.min.toFixed(2)}ms`,\n        maxTime: `${data.max.toFixed(2)}ms`,\n        totalTime: `${data.totalTime.toFixed(2)}ms`,\n        errors: data.errors,\n        errorRate: `${((data.errors / data.count) * 100).toFixed(2)}%`\n      };\n    }\n\n    // Find slowest operations\n    summary.slowestOperations = Object.entries(this.metrics.averageTimes)\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([op, time]) => ({\n        operation: op,\n        avgTime: `${time.toFixed(2)}ms`\n      }));\n\n    return summary;\n  }\n\n  /**\n   * Check if event should use lazy indexing\n   * @param {import('../events/Event.js').Event} event - Event to check\n   * @returns {boolean} True if should use lazy indexing\n   */\n  shouldUseLazyIndexing(event) {\n    const daySpan = Math.ceil(\n      (event.end - event.start) / (24 * 60 * 60 * 1000)\n    );\n    return daySpan > this.config.maxIndexDays;\n  }\n\n  /**\n   * Create lazy index markers for large events\n   * @param {import('../events/Event.js').Event} event - Event to index\n   * @returns {Object} Index boundaries\n   */\n  createLazyIndexMarkers(event) {\n    const markers = {\n      eventId: event.id,\n      start: event.start,\n      end: event.end,\n      indexed: new Set(),\n      pending: false\n    };\n\n    // Index first and last month only initially\n    const startMonth = new Date(event.start.getFullYear(), event.start.getMonth(), 1);\n    const endMonth = new Date(event.end.getFullYear(), event.end.getMonth(), 1);\n\n    markers.indexed.add(this.getMonthKey(startMonth));\n    if (this.getMonthKey(startMonth) !== this.getMonthKey(endMonth)) {\n      markers.indexed.add(this.getMonthKey(endMonth));\n    }\n\n    this.lazyIndexes.set(event.id, markers);\n    return markers;\n  }\n\n  /**\n   * Expand lazy index for a specific date range\n   * @param {string} eventId - Event ID\n   * @param {Date} rangeStart - Start of range to index\n   * @param {Date} rangeEnd - End of range to index\n   * @returns {Promise<Set<string>>} Indexed date strings\n   */\n  async expandLazyIndex(eventId, rangeStart, rangeEnd) {\n    const markers = this.lazyIndexes.get(eventId);\n    if (!markers) {\n      return new Set();\n    }\n\n    // Check if already pending\n    if (markers.pending) {\n      return this.pendingIndexes.get(eventId);\n    }\n\n    markers.pending = true;\n\n    const promise = new Promise((resolve) => {\n      // Simulate async indexing (in real app, could be in worker)\n      setTimeout(() => {\n        const indexed = new Set();\n        const current = new Date(rangeStart);\n\n        while (current <= rangeEnd) {\n          const dateStr = current.toDateString();\n          if (!markers.indexed.has(dateStr)) {\n            indexed.add(dateStr);\n            markers.indexed.add(dateStr);\n          }\n          current.setDate(current.getDate() + 1);\n        }\n\n        markers.pending = false;\n        this.pendingIndexes.delete(eventId);\n        resolve(indexed);\n      }, 0);\n    });\n\n    this.pendingIndexes.set(eventId, promise);\n    return promise;\n  }\n\n  /**\n   * Get month key for date\n   * @private\n   */\n  getMonthKey(date) {\n    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;\n  }\n\n  /**\n   * Cache event with TTL\n   * @param {string} key - Cache key\n   * @param {*} value - Value to cache\n   * @param {string} cacheType - Type of cache to use\n   */\n  cache(key, value, cacheType = 'event') {\n    if (!this.config.enableCache) return;\n\n    let cache;\n    let cacheManagerName;\n\n    switch (cacheType) {\n      case 'event':\n        cache = this.eventCache;\n        cacheManagerName = 'events';\n        break;\n      case 'query':\n        cache = this.queryCache;\n        cacheManagerName = 'queries';\n        break;\n      case 'dateRange':\n        cache = this.dateRangeCache;\n        cacheManagerName = 'dateRanges';\n        break;\n      default:\n        return;\n    }\n\n    cache.put(key, value);\n\n    // Update access time in memory manager\n    if (this.memoryManager) {\n      this.memoryManager.touchCache(cacheManagerName);\n    }\n  }\n\n  /**\n   * Get from cache\n   * @param {string} key - Cache key\n   * @param {string} cacheType - Type of cache\n   * @returns {*} Cached value or undefined\n   */\n  getFromCache(key, cacheType = 'event') {\n    if (!this.config.enableCache) return undefined;\n\n    let result;\n    let cacheManagerName;\n\n    switch (cacheType) {\n      case 'event':\n        result = this.eventCache.get(key);\n        cacheManagerName = 'events';\n        break;\n      case 'query':\n        result = this.queryCache.get(key);\n        cacheManagerName = 'queries';\n        break;\n      case 'dateRange':\n        result = this.dateRangeCache.get(key);\n        cacheManagerName = 'dateRanges';\n        break;\n      default:\n        return undefined;\n    }\n\n    // Update access time on cache hit\n    if (result !== undefined && this.memoryManager) {\n      this.memoryManager.touchCache(cacheManagerName);\n    }\n\n    return result;\n  }\n\n  /**\n   * Invalidate caches for an event\n   * @param {string} eventId - Event ID\n   */\n  invalidateEventCaches(eventId) {\n    // Remove from event cache\n    this.eventCache.delete(eventId);\n\n    // Clear query cache (conservative approach)\n    // In production, track which queries include this event\n    this.queryCache.clear();\n    this.dateRangeCache.clear();\n  }\n\n  /**\n   * Batch operation for efficiency\n   * @param {Function} operation - Operation to batch\n   * @returns {Promise} Batch result\n   */\n  batch(operation) {\n    return new Promise((resolve, reject) => {\n      this.batchQueue.push(operation);\n      this.batchCallbacks.push({ resolve, reject });\n\n      if (this.batchQueue.length >= this.config.batchSize) {\n        this.processBatch();\n      } else if (!this.batchTimer) {\n        // Process batch after 10ms if not full\n        this.batchTimer = setTimeout(() => this.processBatch(), 10);\n      }\n    });\n  }\n\n  /**\n   * Process batched operations\n   * @private\n   */\n  processBatch() {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    if (this.batchQueue.length === 0) return;\n\n    const operations = this.batchQueue.splice(0);\n    const callbacks = this.batchCallbacks.splice(0);\n\n    // Process all operations\n    const results = [];\n    const errors = [];\n\n    operations.forEach((op, index) => {\n      try {\n        results[index] = op();\n      } catch (error) {\n        errors[index] = error;\n      }\n    });\n\n    // Resolve callbacks\n    callbacks.forEach((callback, index) => {\n      if (errors[index]) {\n        callback.reject(errors[index]);\n      } else {\n        callback.resolve(results[index]);\n      }\n    });\n  }\n\n  /**\n   * Start cleanup timer for old indexes\n   * @private\n   */\n  startCleanupTimer() {\n    this.cleanupTimer = setInterval(() => {\n      this.cleanupOldIndexes();\n    }, this.config.cleanupInterval);\n  }\n\n  /**\n   * Clean up old indexes\n   * @private\n   */\n  cleanupOldIndexes() {\n    const now = Date.now();\n    const maxAge = this.config.maxIndexAge;\n\n    // Clean up lazy indexes for events that are too old\n    for (const [eventId, markers] of this.lazyIndexes) {\n      if (markers.end.getTime() < now - maxAge) {\n        this.lazyIndexes.delete(eventId);\n      }\n    }\n\n    // Clean up slow query log\n    if (this.metrics.slowQueries.length > 100) {\n      this.metrics.slowQueries = this.metrics.slowQueries.slice(-100);\n    }\n  }\n\n  /**\n   * Optimize query by checking cache first\n   * @param {string} queryKey - Unique query identifier\n   * @param {Function} queryFn - Function to execute if not cached\n   * @returns {*} Query result\n   */\n  optimizeQuery(queryKey, queryFn) {\n    // Check cache first\n    const cached = this.getFromCache(queryKey, 'query');\n    if (cached !== undefined) {\n      return cached;\n    }\n\n    // Execute query and cache result\n    const result = this.measure(`query:${queryKey}`, queryFn);\n    this.cache(queryKey, result, 'query');\n    return result;\n  }\n\n  /**\n   * Destroy optimizer and clean up resources\n   */\n  destroy() {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = null;\n    }\n\n    this.eventCache.clear();\n    this.queryCache.clear();\n    this.dateRangeCache.clear();\n    this.lazyIndexes.clear();\n    this.pendingIndexes.clear();\n  }\n}","/**\n * ConflictDetector - Detects scheduling conflicts between events\n * Checks for time overlaps, attendee conflicts, and resource conflicts\n */\n\nimport { DateUtils } from '../calendar/DateUtils.js';\n\nexport class ConflictDetector {\n  /**\n   * Create a new ConflictDetector\n   * @param {import('../events/EventStore.js').EventStore} eventStore - Event store instance\n   */\n  constructor(eventStore) {\n    this.eventStore = eventStore;\n    this.conflictIdCounter = 0;\n  }\n\n  /**\n   * Check for conflicts for a specific event\n   * @param {import('../events/Event.js').Event|import('../../types.js').EventData} event - Event to check\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} Conflict summary\n   */\n  checkConflicts(event, options = {}) {\n    // Default options\n    const opts = {\n      checkAttendees: true,\n      checkResources: true,\n      checkLocation: true,\n      ignoreAllDay: false,\n      excludeEventIds: [],\n      includeStatuses: ['confirmed', 'tentative'],\n      bufferMinutes: 0,\n      ...options\n    };\n\n    // Ensure we have an Event object\n    if (!event.start || !event.end) {\n      throw new Error('Event must have start and end dates');\n    }\n\n    const conflicts = [];\n    const affectedEventIds = new Set();\n    const affectedAttendees = new Set();\n\n    // Get potential conflicting events in the time range\n    const searchStart = new Date(event.start.getTime() - opts.bufferMinutes * 60000);\n    const searchEnd = new Date(event.end.getTime() + opts.bufferMinutes * 60000);\n\n    const potentialConflicts = this.eventStore.getEventsInRange(searchStart, searchEnd, false)\n      .filter(e => {\n        // Exclude self\n        if (e.id === event.id) return false;\n        // Exclude specified event IDs\n        if (opts.excludeEventIds.includes(e.id)) return false;\n        // Filter by status\n        if (!opts.includeStatuses.includes(e.status)) return false;\n        // Ignore all-day events if specified\n        if (opts.ignoreAllDay && (e.allDay || event.allDay)) return false;\n        // Ignore cancelled events\n        if (e.status === 'cancelled') return false;\n        return true;\n      });\n\n    // Check each potential conflict\n    for (const conflictingEvent of potentialConflicts) {\n      const eventConflicts = this._detectEventConflicts(\n        event,\n        conflictingEvent,\n        opts\n      );\n\n      if (eventConflicts.length > 0) {\n        conflicts.push(...eventConflicts);\n        affectedEventIds.add(event.id);\n        affectedEventIds.add(conflictingEvent.id);\n\n        // Track affected attendees\n        if (event.attendees) {\n          event.attendees.forEach(a => affectedAttendees.add(a.email));\n        }\n        if (conflictingEvent.attendees) {\n          conflictingEvent.attendees.forEach(a => affectedAttendees.add(a.email));\n        }\n      }\n    }\n\n    // Build summary\n    return this._buildConflictSummary(conflicts, affectedEventIds, affectedAttendees);\n  }\n\n  /**\n   * Check for conflicts between two specific events\n   * @param {import('../events/Event.js').Event} event1 - First event\n   * @param {import('../events/Event.js').Event} event2 - Second event\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictDetails[]} Array of conflicts\n   */\n  checkEventPairConflicts(event1, event2, options = {}) {\n    const opts = {\n      checkAttendees: true,\n      checkResources: true,\n      checkLocation: true,\n      bufferMinutes: 0,\n      ...options\n    };\n\n    return this._detectEventConflicts(event1, event2, opts);\n  }\n\n  /**\n   * Get busy periods for a set of attendees\n   * @param {string[]} attendeeEmails - Attendee email addresses\n   * @param {Date} start - Start of period\n   * @param {Date} end - End of period\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date, eventIds: string[]}>} Busy periods\n   */\n  getBusyPeriods(attendeeEmails, start, end, options = {}) {\n    const opts = {\n      includeStatuses: ['confirmed', 'tentative'],\n      mergePeriods: true,\n      ...options\n    };\n\n    const busyPeriods = [];\n    const events = this.eventStore.getEventsInRange(start, end, false);\n\n    // Find events with these attendees\n    const attendeeEvents = events.filter(event => {\n      if (!opts.includeStatuses.includes(event.status)) return false;\n      if (event.status === 'cancelled') return false;\n\n      return event.attendees && event.attendees.some(attendee =>\n        attendeeEmails.includes(attendee.email)\n      );\n    });\n\n    // Convert to busy periods\n    attendeeEvents.forEach(event => {\n      busyPeriods.push({\n        start: event.start,\n        end: event.end,\n        eventIds: [event.id]\n      });\n    });\n\n    // Merge overlapping periods if requested\n    if (opts.mergePeriods && busyPeriods.length > 1) {\n      return this._mergeBusyPeriods(busyPeriods);\n    }\n\n    return busyPeriods.sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Get free time slots\n   * @param {Date} start - Start of search period\n   * @param {Date} end - End of search period\n   * @param {number} duration - Required duration in minutes\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date}>} Free time slots\n   */\n  getFreePeriods(start, end, duration, options = {}) {\n    const opts = {\n      attendeeEmails: [],\n      businessHoursOnly: false,\n      businessHours: { start: '09:00', end: '17:00' },\n      excludeWeekends: false,\n      ...options\n    };\n\n    const freePeriods = [];\n\n    // Get busy periods\n    const busyPeriods = opts.attendeeEmails.length > 0\n      ? this.getBusyPeriods(opts.attendeeEmails, start, end)\n      : this._getAllBusyPeriods(start, end);\n\n    // Find gaps between busy periods\n    let currentTime = new Date(start);\n\n    for (const busy of busyPeriods) {\n      if (currentTime < busy.start) {\n        // Found a gap\n        const gapDuration = (busy.start - currentTime) / 60000; // minutes\n        if (gapDuration >= duration) {\n          // Check if within business hours if required\n          if (!opts.businessHoursOnly || this._isWithinBusinessHours(currentTime, busy.start, opts)) {\n            freePeriods.push({\n              start: new Date(currentTime),\n              end: new Date(busy.start)\n            });\n          }\n        }\n      }\n      currentTime = new Date(Math.max(currentTime.getTime(), busy.end.getTime()));\n    }\n\n    // Check final period\n    if (currentTime < end) {\n      const gapDuration = (end - currentTime) / 60000;\n      if (gapDuration >= duration) {\n        if (!opts.businessHoursOnly || this._isWithinBusinessHours(currentTime, end, opts)) {\n          freePeriods.push({\n            start: new Date(currentTime),\n            end: new Date(end)\n          });\n        }\n      }\n    }\n\n    return freePeriods;\n  }\n\n  /**\n   * Detect conflicts between two events\n   * @private\n   */\n  _detectEventConflicts(event1, event2, options) {\n    const conflicts = [];\n\n    // Check time overlap with buffer\n    const hasTimeOverlap = this._checkTimeOverlap(\n      event1,\n      event2,\n      options.bufferMinutes\n    );\n\n    if (hasTimeOverlap) {\n      // Time conflict\n      const timeConflict = this._createTimeConflict(event1, event2);\n      conflicts.push(timeConflict);\n\n      // Check attendee conflicts (only if time overlaps)\n      if (options.checkAttendees) {\n        const attendeeConflicts = this._checkAttendeeConflicts(event1, event2);\n        conflicts.push(...attendeeConflicts);\n      }\n\n      // Check resource conflicts (only if time overlaps)\n      if (options.checkResources) {\n        const resourceConflicts = this._checkResourceConflicts(event1, event2);\n        conflicts.push(...resourceConflicts);\n      }\n\n      // Check location conflicts (only if time overlaps)\n      if (options.checkLocation) {\n        const locationConflict = this._checkLocationConflict(event1, event2);\n        if (locationConflict) {\n          conflicts.push(locationConflict);\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for time overlap between events\n   * @private\n   */\n  _checkTimeOverlap(event1, event2, bufferMinutes = 0) {\n    const buffer = bufferMinutes * 60000; // Convert to milliseconds\n\n    const start1 = event1.start.getTime() - buffer;\n    const end1 = event1.end.getTime() + buffer;\n    const start2 = event2.start.getTime();\n    const end2 = event2.end.getTime();\n\n    return !(end1 <= start2 || end2 <= start1);\n  }\n\n  /**\n   * Create time conflict details\n   * @private\n   */\n  _createTimeConflict(event1, event2) {\n    const overlapStart = new Date(Math.max(event1.start.getTime(), event2.start.getTime()));\n    const overlapEnd = new Date(Math.min(event1.end.getTime(), event2.end.getTime()));\n    const overlapMinutes = (overlapEnd - overlapStart) / 60000;\n\n    // Determine severity based on overlap duration and event importance\n    let severity = 'low';\n    if (overlapMinutes >= 60) {\n      severity = 'high';\n    } else if (overlapMinutes >= 30) {\n      severity = 'medium';\n    }\n\n    // Increase severity for confirmed events\n    if (event1.status === 'confirmed' && event2.status === 'confirmed') {\n      severity = severity === 'low' ? 'medium' : severity === 'medium' ? 'high' : 'critical';\n    }\n\n    return {\n      id: `conflict_${++this.conflictIdCounter}`,\n      type: 'time',\n      severity,\n      eventId: event1.id,\n      conflictingEventId: event2.id,\n      description: `Time overlap: ${event1.title} conflicts with ${event2.title}`,\n      overlapStart,\n      overlapEnd,\n      overlapMinutes,\n      metadata: {\n        event1Title: event1.title,\n        event2Title: event2.title,\n        event1Status: event1.status,\n        event2Status: event2.status\n      }\n    };\n  }\n\n  /**\n   * Check for attendee conflicts\n   * @private\n   */\n  _checkAttendeeConflicts(event1, event2) {\n    const conflicts = [];\n\n    if (!event1.attendees || !event2.attendees) {\n      return conflicts;\n    }\n\n    const conflictingAttendees = [];\n\n    for (const attendee1 of event1.attendees) {\n      for (const attendee2 of event2.attendees) {\n        if (attendee1.email === attendee2.email) {\n          // Same attendee in both events\n          conflictingAttendees.push(attendee1.email);\n        }\n      }\n    }\n\n    if (conflictingAttendees.length > 0) {\n      // Determine severity based on attendee responses\n      let severity = 'medium';\n\n      // Check if any conflicting attendee has accepted both\n      const hasAcceptedBoth = conflictingAttendees.some(email => {\n        const a1 = event1.attendees.find(a => a.email === email);\n        const a2 = event2.attendees.find(a => a.email === email);\n        return a1?.responseStatus === 'accepted' && a2?.responseStatus === 'accepted';\n      });\n\n      if (hasAcceptedBoth) {\n        severity = 'critical';\n      }\n\n      conflicts.push({\n        id: `conflict_${++this.conflictIdCounter}`,\n        type: 'attendee',\n        severity,\n        eventId: event1.id,\n        conflictingEventId: event2.id,\n        description: `Attendee conflict: ${conflictingAttendees.length} attendee(s) double-booked`,\n        conflictingAttendees,\n        metadata: {\n          attendeeCount: conflictingAttendees.length,\n          attendeeEmails: conflictingAttendees\n        }\n      });\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for resource conflicts\n   * @private\n   */\n  _checkResourceConflicts(event1, event2) {\n    const conflicts = [];\n\n    // Check if events have resource attendees\n    const resources1 = event1.attendees?.filter(a => a.resource) || [];\n    const resources2 = event2.attendees?.filter(a => a.resource) || [];\n\n    for (const resource1 of resources1) {\n      for (const resource2 of resources2) {\n        if (resource1.email === resource2.email) {\n          conflicts.push({\n            id: `conflict_${++this.conflictIdCounter}`,\n            type: 'resource',\n            severity: 'critical', // Resource conflicts are always critical\n            eventId: event1.id,\n            conflictingEventId: event2.id,\n            description: `Resource conflict: ${resource1.name} is double-booked`,\n            conflictingResource: resource1.email,\n            metadata: {\n              resourceName: resource1.name,\n              resourceEmail: resource1.email\n            }\n          });\n        }\n      }\n    }\n\n    return conflicts;\n  }\n\n  /**\n   * Check for location conflicts\n   * @private\n   */\n  _checkLocationConflict(event1, event2) {\n    if (!event1.location || !event2.location) {\n      return null;\n    }\n\n    // Normalize locations for comparison\n    const loc1 = event1.location.trim().toLowerCase();\n    const loc2 = event2.location.trim().toLowerCase();\n\n    if (loc1 === loc2) {\n      return {\n        id: `conflict_${++this.conflictIdCounter}`,\n        type: 'location',\n        severity: 'high', // Location conflicts are typically high severity\n        eventId: event1.id,\n        conflictingEventId: event2.id,\n        description: `Location conflict: ${event1.location} is double-booked`,\n        metadata: {\n          location: event1.location\n        }\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Build conflict summary\n   * @private\n   */\n  _buildConflictSummary(conflicts, affectedEventIds, affectedAttendees) {\n    const conflictsByType = {};\n    const conflictsBySeverity = {};\n\n    // Count by type and severity\n    for (const conflict of conflicts) {\n      conflictsByType[conflict.type] = (conflictsByType[conflict.type] || 0) + 1;\n      conflictsBySeverity[conflict.severity] = (conflictsBySeverity[conflict.severity] || 0) + 1;\n    }\n\n    return {\n      hasConflicts: conflicts.length > 0,\n      totalConflicts: conflicts.length,\n      conflicts,\n      conflictsByType,\n      conflictsBySeverity,\n      affectedEventIds: Array.from(affectedEventIds),\n      affectedAttendees: Array.from(affectedAttendees)\n    };\n  }\n\n  /**\n   * Merge overlapping busy periods\n   * @private\n   */\n  _mergeBusyPeriods(periods) {\n    if (periods.length <= 1) return periods;\n\n    // Sort by start time\n    periods.sort((a, b) => a.start - b.start);\n\n    const merged = [periods[0]];\n\n    for (let i = 1; i < periods.length; i++) {\n      const current = periods[i];\n      const last = merged[merged.length - 1];\n\n      if (current.start <= last.end) {\n        // Overlapping or adjacent, merge them\n        last.end = new Date(Math.max(last.end.getTime(), current.end.getTime()));\n        last.eventIds.push(...current.eventIds);\n      } else {\n        // No overlap, add as new period\n        merged.push(current);\n      }\n    }\n\n    return merged;\n  }\n\n  /**\n   * Get all busy periods\n   * @private\n   */\n  _getAllBusyPeriods(start, end) {\n    const events = this.eventStore.getEventsInRange(start, end, false)\n      .filter(e => e.status !== 'cancelled');\n\n    return events.map(event => ({\n      start: event.start,\n      end: event.end,\n      eventIds: [event.id]\n    })).sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Check if time period is within business hours\n   * @private\n   */\n  _isWithinBusinessHours(start, end, options) {\n    // Simple implementation - can be enhanced\n    const startHour = start.getHours();\n    const endHour = end.getHours();\n\n    const businessStart = parseInt(options.businessHours.start.split(':')[0]);\n    const businessEnd = parseInt(options.businessHours.end.split(':')[0]);\n\n    return startHour >= businessStart && endHour <= businessEnd;\n  }\n}","import { Event } from './Event.js';\nimport { DateUtils } from '../calendar/DateUtils.js';\nimport { RecurrenceEngine } from './RecurrenceEngine.js';\nimport { PerformanceOptimizer } from '../performance/PerformanceOptimizer.js';\nimport { ConflictDetector } from '../conflicts/ConflictDetector.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * EventStore - Manages calendar events with efficient querying\n * Uses Map for O(1) lookups and spatial indexing concepts for date queries\n * Now with performance optimizations for large datasets\n */\nexport class EventStore {\n  constructor(config = {}) {\n    // Primary storage - Map for O(1) ID lookups\n    /** @type {Map<string, Event>} */\n    this.events = new Map();\n\n    // Indices for efficient queries (using UTC for consistent indexing)\n    this.indices = {\n      /** @type {Map<string, Set<string>>} UTC Date string -> Set of event IDs */\n      byDate: new Map(),\n      /** @type {Map<string, Set<string>>} YYYY-MM (UTC) -> Set of event IDs */\n      byMonth: new Map(),\n      /** @type {Set<string>} Set of recurring event IDs */\n      recurring: new Set(),\n      /** @type {Map<string, Set<string>>} Category -> Set of event IDs */\n      byCategory: new Map(),\n      /** @type {Map<string, Set<string>>} Status -> Set of event IDs */\n      byStatus: new Map()\n    };\n\n    // Timezone manager for conversions\n    this.timezoneManager = new TimezoneManager();\n\n    // Default timezone for the store (can be overridden)\n    this.defaultTimezone = config.timezone || this.timezoneManager.getSystemTimezone();\n\n    // Performance optimizer\n    this.optimizer = new PerformanceOptimizer(config.performance);\n\n    // Conflict detector\n    this.conflictDetector = new ConflictDetector(this);\n\n    // Batch operation state\n    this.isBatchMode = false;\n    this.batchNotifications = [];\n    this.batchBackup = null; // For rollback support\n\n    // Change tracking\n    /** @type {number} */\n    this.version = 0;\n    /** @type {Set<import('../../types.js').EventListener>} */\n    this.listeners = new Set();\n  }\n\n  /**\n   * Add an event to the store\n   * @param {Event|import('../../types.js').EventData} event - The event to add\n   * @returns {Event} The added event\n   * @throws {Error} If event with same ID already exists\n   */\n  addEvent(event) {\n    return this.optimizer.measure('addEvent', () => {\n      if (!(event instanceof Event)) {\n        event = new Event(event);\n      }\n\n      if (this.events.has(event.id)) {\n        throw new Error(`Event with id ${event.id} already exists`);\n      }\n\n      // Store the event\n      this.events.set(event.id, event);\n\n      // Cache the event\n      this.optimizer.cache(event.id, event, 'event');\n\n      // Update indices\n      this._indexEvent(event);\n\n      // Notify listeners (batch if in batch mode)\n      if (this.isBatchMode) {\n        this.batchNotifications.push({\n          type: 'add',\n          event,\n          version: ++this.version\n        });\n      } else {\n        this._notifyChange({\n          type: 'add',\n          event,\n          version: ++this.version\n        });\n      }\n\n      return event;\n    });\n  }\n\n  /**\n   * Update an existing event\n   * @param {string} eventId - The event ID\n   * @param {Partial<import('../../types.js').EventData>} updates - Properties to update\n   * @returns {Event} The updated event\n   * @throws {Error} If event not found\n   */\n  updateEvent(eventId, updates) {\n    const existingEvent = this.events.get(eventId);\n    if (!existingEvent) {\n      throw new Error(`Event with id ${eventId} not found`);\n    }\n\n    // Remove old indices\n    this._unindexEvent(existingEvent);\n\n    // Create updated event\n    const updatedEvent = existingEvent.clone(updates);\n\n    // Store updated event\n    this.events.set(eventId, updatedEvent);\n\n    // Re-index\n    this._indexEvent(updatedEvent);\n\n    // Notify listeners\n    this._notifyChange({\n      type: 'update',\n      event: updatedEvent,\n      oldEvent: existingEvent,\n      version: ++this.version\n    });\n\n    return updatedEvent;\n  }\n\n  /**\n   * Remove an event from the store\n   * @param {string} eventId - The event ID to remove\n   * @returns {boolean} True if removed, false if not found\n   */\n  removeEvent(eventId) {\n    const event = this.events.get(eventId);\n    if (!event) {\n      return false;\n    }\n\n    // Remove from primary storage\n    this.events.delete(eventId);\n\n    // Remove from indices\n    this._unindexEvent(event);\n\n    // Notify listeners\n    this._notifyChange({\n      type: 'remove',\n      event,\n      version: ++this.version\n    });\n\n    return true;\n  }\n\n  /**\n   * Get an event by ID\n   * @param {string} eventId - The event ID\n   * @returns {Event|null} The event or null if not found\n   */\n  getEvent(eventId) {\n    // Check cache first\n    const cached = this.optimizer.getFromCache(eventId, 'event');\n    if (cached) {\n      return cached;\n    }\n\n    // Get from store\n    const event = this.events.get(eventId) || null;\n\n    // Cache if found\n    if (event) {\n      this.optimizer.cache(eventId, event, 'event');\n    }\n\n    return event;\n  }\n\n  /**\n   * Get all events\n   * @returns {Event[]} Array of all events\n   */\n  getAllEvents() {\n    return Array.from(this.events.values());\n  }\n\n  /**\n   * Query events with filters\n   * @param {import('../../types.js').QueryFilters} [filters={}] - Query filters\n   * @returns {Event[]} Filtered events\n   */\n  queryEvents(filters = {}) {\n    let results = Array.from(this.events.values());\n\n    // Filter by date range\n    if (filters.start || filters.end) {\n      const start = filters.start ? new Date(filters.start) : null;\n      const end = filters.end ? new Date(filters.end) : null;\n\n      results = results.filter(event => {\n        if (start && event.end < start) return false;\n        if (end && event.start > end) return false;\n        return true;\n      });\n    }\n\n    // Filter by specific date\n    if (filters.date) {\n      const date = new Date(filters.date);\n      results = results.filter(event => event.occursOn(date));\n    }\n\n    // Filter by month\n    if (filters.month && filters.year) {\n      const monthKey = `${filters.year}-${String(filters.month).padStart(2, '0')}`;\n      const eventIds = this.indices.byMonth.get(monthKey) || new Set();\n      results = results.filter(event => eventIds.has(event.id));\n    }\n\n    // Filter by all-day events\n    if (filters.hasOwnProperty('allDay')) {\n      results = results.filter(event => event.allDay === filters.allDay);\n    }\n\n    // Filter by recurring\n    if (filters.hasOwnProperty('recurring')) {\n      results = results.filter(event => event.recurring === filters.recurring);\n    }\n\n    // Filter by status\n    if (filters.status) {\n      results = results.filter(event => event.status === filters.status);\n    }\n\n    // Filter by categories\n    if (filters.categories && filters.categories.length > 0) {\n      results = results.filter(event =>\n        filters.matchAllCategories\n          ? event.hasAllCategories(filters.categories)\n          : event.hasAnyCategory(filters.categories)\n      );\n    }\n\n    // Filter by having attendees\n    if (filters.hasOwnProperty('hasAttendees')) {\n      results = results.filter(event => filters.hasAttendees ? event.hasAttendees : !event.hasAttendees);\n    }\n\n    // Filter by organizer email\n    if (filters.organizerEmail) {\n      results = results.filter(event =>\n        event.organizer && event.organizer.email === filters.organizerEmail\n      );\n    }\n\n    // Sort results\n    if (filters.sort) {\n      results.sort((a, b) => {\n        switch (filters.sort) {\n          case 'start':\n            return a.start - b.start;\n          case 'end':\n            return a.end - b.end;\n          case 'duration':\n            return a.duration - b.duration;\n          case 'title':\n            return a.title.localeCompare(b.title);\n          default:\n            return 0;\n        }\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Get events for a specific date\n   * @param {Date} date - The date to query\n   * @param {string} [timezone] - Timezone for the query (defaults to store timezone)\n   * @returns {Event[]} Events occurring on the date, sorted by start time\n   */\n  getEventsForDate(date, timezone = null) {\n    timezone = timezone || this.defaultTimezone;\n\n    // Use local date string for the query date (in the calendar's timezone)\n    const dateStr = DateUtils.getLocalDateString(date);\n\n    // Get all events indexed for this date\n    const allEvents = [];\n\n    // Since events might span multiple days in different timezones,\n    // we need to check events from surrounding dates too\n    const checkDate = new Date(date);\n    for (let offset = -1; offset <= 1; offset++) {\n      const tempDate = new Date(checkDate);\n      tempDate.setDate(tempDate.getDate() + offset);\n      const tempDateStr = DateUtils.getLocalDateString(tempDate);\n      const eventIds = this.indices.byDate.get(tempDateStr) || new Set();\n\n      for (const id of eventIds) {\n        const event = this.events.get(id);\n        if (event && !allEvents.find(e => e.id === event.id)) {\n          // Check if event actually occurs on the requested date in the given timezone\n          const eventStartLocal = event.getStartInTimezone(timezone);\n          const eventEndLocal = event.getEndInTimezone(timezone);\n\n          const startOfDay = new Date(date);\n          startOfDay.setHours(0, 0, 0, 0);\n          const endOfDay = new Date(date);\n          endOfDay.setHours(23, 59, 59, 999);\n\n          // Event overlaps with this day if it starts before end of day and ends after start of day\n          if (eventStartLocal <= endOfDay && eventEndLocal >= startOfDay) {\n            allEvents.push(event);\n          }\n        }\n      }\n    }\n\n    return allEvents.sort((a, b) => {\n      // Sort by start time in the specified timezone\n      const aStart = a.getStartInTimezone(timezone);\n      const bStart = b.getStartInTimezone(timezone);\n      const timeCompare = aStart - bStart;\n      if (timeCompare !== 0) return timeCompare;\n      return b.duration - a.duration; // Longer events first\n    });\n  }\n\n  /**\n   * Get events that overlap with a given time range\n   * @param {Date} start - Start time\n   * @param {Date} end - End time\n   * @param {string} [excludeId=null] - Optional event ID to exclude (useful when checking for conflicts)\n   * @returns {Event[]} Array of overlapping events\n   */\n  getOverlappingEvents(start, end, excludeId = null) {\n    const overlapping = [];\n\n    // Get all events in the date range\n    const startDate = DateUtils.startOfDay(start);\n    const endDate = DateUtils.endOfDay(end);\n    const dates = DateUtils.getDateRange(startDate, endDate);\n\n    // Collect all events from those dates\n    const checkedIds = new Set();\n    dates.forEach(date => {\n      const dateStr = date.toDateString();\n      const eventIds = this.indices.byDate.get(dateStr) || new Set();\n\n      eventIds.forEach(id => {\n        if (!checkedIds.has(id) && id !== excludeId) {\n          checkedIds.add(id);\n          const event = this.events.get(id);\n\n          if (event && event.overlaps({ start, end })) {\n            overlapping.push(event);\n          }\n        }\n      });\n    });\n\n    return overlapping.sort((a, b) => a.start - b.start);\n  }\n\n  /**\n   * Check if an event would conflict with existing events\n   * @param {Date} start - Start time\n   * @param {Date} end - End time\n   * @param {string} excludeId - Optional event ID to exclude\n   * @returns {boolean} True if there are conflicts\n   */\n  hasConflicts(start, end, excludeId = null) {\n    return this.getOverlappingEvents(start, end, excludeId).length > 0;\n  }\n\n  /**\n   * Get events grouped by overlapping time slots\n   * Useful for calculating event positions in week/day views\n   * @param {Date} date - The date to analyze\n   * @param {boolean} timedOnly - Only include timed events (not all-day)\n   * @returns {Array<Event[]>} Array of event groups that overlap\n   */\n  getOverlapGroups(date, timedOnly = true) {\n    let events = this.getEventsForDate(date);\n\n    if (timedOnly) {\n      events = events.filter(e => !e.allDay);\n    }\n\n    const groups = [];\n    const processed = new Set();\n\n    events.forEach(event => {\n      if (processed.has(event.id)) return;\n\n      // Start a new group with this event\n      const group = [event];\n      processed.add(event.id);\n\n      // Find all events that overlap with any event in this group\n      let i = 0;\n      while (i < group.length) {\n        const currentEvent = group[i];\n\n        events.forEach(otherEvent => {\n          if (!processed.has(otherEvent.id) && currentEvent.overlaps(otherEvent)) {\n            group.push(otherEvent);\n            processed.add(otherEvent.id);\n          }\n        });\n\n        i++;\n      }\n\n      groups.push(group);\n    });\n\n    return groups;\n  }\n\n  /**\n   * Calculate positions for overlapping events (for rendering)\n   * @param {Event[]} events - Array of overlapping events\n   * @returns {Map<string, {column: number, totalColumns: number}>} Position data for each event\n   */\n  calculateEventPositions(events) {\n    const positions = new Map();\n\n    if (events.length === 0) return positions;\n\n    // Sort by start time, then by duration (longer events first)\n    events.sort((a, b) => {\n      const startDiff = a.start - b.start;\n      if (startDiff !== 0) return startDiff;\n      return (b.end - b.start) - (a.end - a.start);\n    });\n\n    // Track which columns are occupied at each time\n    const columns = [];\n\n    events.forEach(event => {\n      // Find the first available column\n      let column = 0;\n      while (column < columns.length) {\n        const columnEvents = columns[column];\n        const hasConflict = columnEvents.some(e => e.overlaps(event));\n\n        if (!hasConflict) {\n          break;\n        }\n        column++;\n      }\n\n      // Add event to the column\n      if (!columns[column]) {\n        columns[column] = [];\n      }\n      columns[column].push(event);\n\n      positions.set(event.id, {\n        column: column,\n        totalColumns: 0 // Will be updated after all events are placed\n      });\n    });\n\n    // Update total columns for all events\n    const totalColumns = columns.length;\n    positions.forEach(pos => {\n      pos.totalColumns = totalColumns;\n    });\n\n    return positions;\n  }\n\n  /**\n   * Get events for a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {boolean|string} expandRecurring - Whether to expand recurring events, or timezone string\n   * @param {string} [timezone] - Timezone for the query (if expandRecurring is boolean)\n   * @returns {Event[]}\n   */\n  getEventsInRange(start, end, expandRecurring = true, timezone = null) {\n    // Handle overloaded parameters\n    if (typeof expandRecurring === 'string') {\n      timezone = expandRecurring;\n      expandRecurring = true;\n    }\n\n    timezone = timezone || this.defaultTimezone;\n\n    // Convert range to UTC for querying\n    const startUTC = this.timezoneManager.toUTC(start, timezone);\n    const endUTC = this.timezoneManager.toUTC(end, timezone);\n\n    // Query using UTC times\n    const baseEvents = this.queryEvents({\n      start: startUTC,\n      end: endUTC,\n      sort: 'start'\n    });\n\n    if (!expandRecurring) {\n      return baseEvents;\n    }\n\n    // Expand recurring events\n    const expandedEvents = [];\n    baseEvents.forEach(event => {\n      if (event.recurring && event.recurrenceRule) {\n        const occurrences = this.expandRecurringEvent(event, start, end, timezone);\n        expandedEvents.push(...occurrences);\n      } else {\n        expandedEvents.push(event);\n      }\n    });\n\n    return expandedEvents.sort((a, b) => {\n      // Sort by start time in the specified timezone\n      const aStart = a.getStartInTimezone(timezone);\n      const bStart = b.getStartInTimezone(timezone);\n      return aStart - bStart;\n    });\n  }\n\n  /**\n   * Expand a recurring event into individual occurrences\n   * @param {Event} event - The recurring event\n   * @param {Date} rangeStart - Start of the expansion range\n   * @param {Date} rangeEnd - End of the expansion range\n   * @param {string} [timezone] - Timezone for the expansion\n   * @returns {Event[]} Array of event occurrences\n   */\n  expandRecurringEvent(event, rangeStart, rangeEnd, timezone = null) {\n    if (!event.recurring || !event.recurrenceRule) {\n      return [event];\n    }\n\n    timezone = timezone || this.defaultTimezone;\n\n    // Expand in the event's timezone for accurate recurrence calculation\n    const eventTimezone = event.timeZone || timezone;\n    const occurrences = RecurrenceEngine.expandEvent(event, rangeStart, rangeEnd);\n\n    return occurrences.map((occurrence, index) => {\n      // Create a new event instance for each occurrence\n      const occurrenceEvent = event.clone({\n        id: `${event.id}_occurrence_${index}`,\n        start: occurrence.start,\n        end: occurrence.end,\n        timeZone: eventTimezone,\n        metadata: {\n          ...event.metadata,\n          recurringEventId: event.id,\n          occurrenceIndex: index\n        }\n      });\n\n      return occurrenceEvent;\n    });\n  }\n\n  /**\n   * Clear all events\n   */\n  clear() {\n    const oldEvents = this.getAllEvents();\n\n    this.events.clear();\n    this.indices.byDate.clear();\n    this.indices.byMonth.clear();\n    this.indices.recurring.clear();\n\n    this._notifyChange({\n      type: 'clear',\n      oldEvents,\n      version: ++this.version\n    });\n  }\n\n  /**\n   * Bulk load events\n   * @param {Event[]} events - Array of events or event data\n   */\n  loadEvents(events) {\n    this.clear();\n\n    for (const eventData of events) {\n      this.addEvent(eventData);\n    }\n  }\n\n  /**\n   * Subscribe to store changes\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(callback) {\n    this.listeners.add(callback);\n\n    return () => {\n      this.listeners.delete(callback);\n    };\n  }\n\n  /**\n   * Index an event for efficient queries\n   * @private\n   */\n  _indexEvent(event) {\n    // Check if should use lazy indexing for large date ranges\n    if (this.optimizer.shouldUseLazyIndexing(event)) {\n      this._indexEventLazy(event);\n      return;\n    }\n\n    // Index by local dates in the event's timezone\n    // This ensures events appear on the correct calendar day\n    const eventStartLocal = event.getStartInTimezone(event.timeZone);\n    const eventEndLocal = event.getEndInTimezone(event.endTimeZone || event.timeZone);\n\n    const startDate = DateUtils.startOfDay(eventStartLocal);\n    const endDate = DateUtils.endOfDay(eventEndLocal);\n\n    // For each day the event spans (in local time), add to date index\n    const dates = DateUtils.getDateRange(startDate, endDate);\n\n    dates.forEach(date => {\n      const dateStr = DateUtils.getLocalDateString(date);\n\n      if (!this.indices.byDate.has(dateStr)) {\n        this.indices.byDate.set(dateStr, new Set());\n      }\n      this.indices.byDate.get(dateStr).add(event.id);\n    });\n\n    // Index by month(s) using UTC\n    const startMonth = `${startDate.getFullYear()}-${String(startDate.getMonth() + 1).padStart(2, '0')}`;\n    const endMonth = `${endDate.getFullYear()}-${String(endDate.getMonth() + 1).padStart(2, '0')}`;\n\n    // Add to all months the event spans\n    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);\n    while (currentMonth <= endDate) {\n      const monthKey = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;\n\n      if (!this.indices.byMonth.has(monthKey)) {\n        this.indices.byMonth.set(monthKey, new Set());\n      }\n      this.indices.byMonth.get(monthKey).add(event.id);\n\n      currentMonth.setMonth(currentMonth.getMonth() + 1);\n    }\n\n    // Index by categories\n    if (event.categories && event.categories.length > 0) {\n      event.categories.forEach(category => {\n        if (!this.indices.byCategory.has(category)) {\n          this.indices.byCategory.set(category, new Set());\n        }\n        this.indices.byCategory.get(category).add(event.id);\n      });\n    }\n\n    // Index by status\n    if (event.status) {\n      if (!this.indices.byStatus.has(event.status)) {\n        this.indices.byStatus.set(event.status, new Set());\n      }\n      this.indices.byStatus.get(event.status).add(event.id);\n    }\n\n    // Index recurring events\n    if (event.recurring) {\n      this.indices.recurring.add(event.id);\n    }\n  }\n\n  /**\n   * Lazy index for events with large date ranges\n   * @private\n   */\n  _indexEventLazy(event) {\n    // Create lazy index markers\n    const markers = this.optimizer.createLazyIndexMarkers(event);\n\n    // Index only the boundaries initially (in event's local timezone)\n    const eventStartLocal = event.getStartInTimezone(event.timeZone);\n    const eventEndLocal = event.getEndInTimezone(event.endTimeZone || event.timeZone);\n\n    const startDate = DateUtils.startOfDay(eventStartLocal);\n    const endDate = DateUtils.endOfDay(eventEndLocal);\n\n    // Index first week\n    const firstWeekEnd = new Date(startDate);\n    firstWeekEnd.setDate(firstWeekEnd.getDate() + 7);\n    const firstWeekDates = DateUtils.getDateRange(startDate,\n      firstWeekEnd < endDate ? firstWeekEnd : endDate);\n\n    firstWeekDates.forEach(date => {\n      const dateStr = DateUtils.getLocalDateString(date);\n      if (!this.indices.byDate.has(dateStr)) {\n        this.indices.byDate.set(dateStr, new Set());\n      }\n      this.indices.byDate.get(dateStr).add(event.id);\n    });\n\n    // Index last week if different from first\n    if (endDate > firstWeekEnd) {\n      const lastWeekStart = new Date(endDate);\n      lastWeekStart.setDate(lastWeekStart.getDate() - 7);\n      const lastWeekDates = DateUtils.getDateRange(\n        lastWeekStart > startDate ? lastWeekStart : startDate,\n        endDate\n      );\n\n      lastWeekDates.forEach(date => {\n        const dateStr = DateUtils.getLocalDateString(date);\n        if (!this.indices.byDate.has(dateStr)) {\n          this.indices.byDate.set(dateStr, new Set());\n        }\n        this.indices.byDate.get(dateStr).add(event.id);\n      });\n    }\n\n    // Index months as normal\n    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth(), 1);\n    while (currentMonth <= endDate) {\n      const monthKey = `${currentMonth.getFullYear()}-${String(currentMonth.getMonth() + 1).padStart(2, '0')}`;\n      if (!this.indices.byMonth.has(monthKey)) {\n        this.indices.byMonth.set(monthKey, new Set());\n      }\n      this.indices.byMonth.get(monthKey).add(event.id);\n      currentMonth.setMonth(currentMonth.getMonth() + 1);\n    }\n\n    // Index other properties normally\n    if (event.categories && event.categories.length > 0) {\n      event.categories.forEach(category => {\n        if (!this.indices.byCategory.has(category)) {\n          this.indices.byCategory.set(category, new Set());\n        }\n        this.indices.byCategory.get(category).add(event.id);\n      });\n    }\n\n    if (event.status) {\n      if (!this.indices.byStatus.has(event.status)) {\n        this.indices.byStatus.set(event.status, new Set());\n      }\n      this.indices.byStatus.get(event.status).add(event.id);\n    }\n\n    if (event.recurring) {\n      this.indices.recurring.add(event.id);\n    }\n  }\n\n  /**\n   * Remove event from indices\n   * @private\n   */\n  _unindexEvent(event) {\n    // Remove from date indices\n    for (const [dateStr, eventIds] of this.indices.byDate) {\n      eventIds.delete(event.id);\n      if (eventIds.size === 0) {\n        this.indices.byDate.delete(dateStr);\n      }\n    }\n\n    // Remove from month indices\n    for (const [monthKey, eventIds] of this.indices.byMonth) {\n      eventIds.delete(event.id);\n      if (eventIds.size === 0) {\n        this.indices.byMonth.delete(monthKey);\n      }\n    }\n\n    // Remove from recurring index\n    this.indices.recurring.delete(event.id);\n  }\n\n  /**\n   * Notify listeners of changes\n   * @private\n   */\n  _notifyChange(change) {\n    for (const listener of this.listeners) {\n      try {\n        listener(change);\n      } catch (error) {\n        console.error('Error in EventStore listener:', error);\n      }\n    }\n  }\n\n  /**\n   * Get store statistics\n   * @returns {Object}\n   */\n  getStats() {\n    return {\n      totalEvents: this.events.size,\n      recurringEvents: this.indices.recurring.size,\n      indexedDates: this.indices.byDate.size,\n      indexedMonths: this.indices.byMonth.size,\n      indexedCategories: this.indices.byCategory.size,\n      indexedStatuses: this.indices.byStatus.size,\n      version: this.version,\n      performanceMetrics: this.optimizer.getMetrics()\n    };\n  }\n\n  // ============ Batch Operations ============\n\n  /**\n   * Start batch mode for bulk operations\n   * Delays notifications until batch is committed\n   * @param {boolean} [enableRollback=false] - Enable rollback support (creates backup)\n   */\n  startBatch(enableRollback = false) {\n    this.isBatchMode = true;\n    this.batchNotifications = [];\n\n    // Create backup for rollback if requested\n    if (enableRollback) {\n      this.batchBackup = {\n        events: new Map(this.events),\n        indices: {\n          byDate: new Map(Array.from(this.indices.byDate.entries()).map(([k, v]) => [k, new Set(v)])),\n          byMonth: new Map(Array.from(this.indices.byMonth.entries()).map(([k, v]) => [k, new Set(v)])),\n          recurring: new Set(this.indices.recurring),\n          byCategory: new Map(Array.from(this.indices.byCategory.entries()).map(([k, v]) => [k, new Set(v)])),\n          byStatus: new Map(Array.from(this.indices.byStatus.entries()).map(([k, v]) => [k, new Set(v)]))\n        },\n        version: this.version\n      };\n    }\n  }\n\n  /**\n   * Commit batch operations\n   * Sends all notifications at once\n   */\n  commitBatch() {\n    if (!this.isBatchMode) return;\n\n    this.isBatchMode = false;\n\n    // Clear backup after successful commit\n    this.batchBackup = null;\n\n    // Send a single bulk notification\n    if (this.batchNotifications.length > 0) {\n      this._notifyChange({\n        type: 'batch',\n        changes: this.batchNotifications,\n        count: this.batchNotifications.length,\n        version: ++this.version\n      });\n    }\n\n    this.batchNotifications = [];\n  }\n\n  /**\n   * Rollback batch operations\n   * Restores state to before batch started\n   */\n  rollbackBatch() {\n    if (!this.isBatchMode) return;\n\n    this.isBatchMode = false;\n\n    // Restore backup if available\n    if (this.batchBackup) {\n      this.events = this.batchBackup.events;\n      this.indices = this.batchBackup.indices;\n      this.version = this.batchBackup.version;\n      this.batchBackup = null;\n\n      // Clear cache\n      this.optimizer.clearCache();\n    }\n\n    this.batchNotifications = [];\n  }\n\n  /**\n   * Execute batch operation with automatic rollback on error\n   * @param {Function} operation - Operation to execute\n   * @param {boolean} [enableRollback=true] - Enable automatic rollback on error\n   * @returns {*} Result of operation\n   * @throws {Error} If operation fails\n   */\n  async executeBatch(operation, enableRollback = true) {\n    this.startBatch(enableRollback);\n\n    try {\n      const result = await operation();\n      this.commitBatch();\n      return result;\n    } catch (error) {\n      if (enableRollback) {\n        this.rollbackBatch();\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Add multiple events in batch\n   * @param {Array<Event|import('../../types.js').EventData>} events - Events to add\n   * @returns {Event[]} Added events\n   */\n  addEvents(events) {\n    return this.optimizer.measure('addEvents', () => {\n      this.startBatch();\n      const results = [];\n      const errors = [];\n\n      for (const eventData of events) {\n        try {\n          results.push(this.addEvent(eventData));\n        } catch (error) {\n          errors.push({ event: eventData, error: error.message });\n        }\n      }\n\n      this.commitBatch();\n\n      if (errors.length > 0) {\n        console.warn(`Failed to add ${errors.length} events:`, errors);\n      }\n\n      return results;\n    });\n  }\n\n  /**\n   * Update multiple events in batch\n   * @param {Array<{id: string, updates: Object}>} updates - Update operations\n   * @returns {Event[]} Updated events\n   */\n  updateEvents(updates) {\n    return this.optimizer.measure('updateEvents', () => {\n      this.startBatch();\n      const results = [];\n      const errors = [];\n\n      for (const { id, updates: eventUpdates } of updates) {\n        try {\n          results.push(this.updateEvent(id, eventUpdates));\n        } catch (error) {\n          errors.push({ id, error: error.message });\n        }\n      }\n\n      this.commitBatch();\n\n      if (errors.length > 0) {\n        console.warn(`Failed to update ${errors.length} events:`, errors);\n      }\n\n      return results;\n    });\n  }\n\n  /**\n   * Remove multiple events in batch\n   * @param {string[]} eventIds - Event IDs to remove\n   * @returns {number} Number of events removed\n   */\n  removeEvents(eventIds) {\n    return this.optimizer.measure('removeEvents', () => {\n      this.startBatch();\n      let removed = 0;\n\n      for (const id of eventIds) {\n        if (this.removeEvent(id)) {\n          removed++;\n        }\n      }\n\n      this.commitBatch();\n      return removed;\n    });\n  }\n\n  // ============ Performance Methods ============\n\n  /**\n   * Get performance metrics\n   * @returns {Object} Performance metrics\n   */\n  getPerformanceMetrics() {\n    return this.optimizer.getMetrics();\n  }\n\n  /**\n   * Clear all caches\n   */\n  clearCaches() {\n    this.optimizer.eventCache.clear();\n    this.optimizer.queryCache.clear();\n    this.optimizer.dateRangeCache.clear();\n  }\n\n  /**\n   * Optimize indices by removing old or irrelevant entries\n   * @param {Date} [cutoffDate] - Remove indices older than this date\n   */\n  optimizeIndices(cutoffDate) {\n    if (!cutoffDate) {\n      cutoffDate = new Date();\n      cutoffDate.setMonth(cutoffDate.getMonth() - 6); // Default: 6 months ago\n    }\n\n    const cutoffStr = cutoffDate.toDateString();\n    let removed = 0;\n\n    // Clean up date indices\n    for (const [dateStr, eventIds] of this.indices.byDate) {\n      const date = new Date(dateStr);\n      if (date < cutoffDate) {\n        // Check if any events still need this index\n        let stillNeeded = false;\n        for (const eventId of eventIds) {\n          const event = this.events.get(eventId);\n          if (event && event.end >= cutoffDate) {\n            stillNeeded = true;\n            break;\n          }\n        }\n\n        if (!stillNeeded) {\n          this.indices.byDate.delete(dateStr);\n          removed++;\n        }\n      }\n    }\n\n    console.log(`Optimized indices: removed ${removed} old date entries`);\n    return removed;\n  }\n\n  /**\n   * Destroy the store and clean up resources\n   */\n  destroy() {\n    this.clear();\n    this.optimizer.destroy();\n    this.listeners.clear();\n  }\n\n  // ============ Conflict Detection Methods ============\n\n  /**\n   * Check for conflicts for an event\n   * @param {Event|import('../../types.js').EventData} event - Event to check\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} Conflict summary\n   */\n  checkConflicts(event, options = {}) {\n    return this.conflictDetector.checkConflicts(event, options);\n  }\n\n  /**\n   * Check conflicts between two events\n   * @param {string} eventId1 - First event ID\n   * @param {string} eventId2 - Second event ID\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictDetails[]} Conflicts between events\n   */\n  checkEventPairConflicts(eventId1, eventId2, options = {}) {\n    const event1 = this.getEvent(eventId1);\n    const event2 = this.getEvent(eventId2);\n\n    if (!event1 || !event2) {\n      throw new Error('One or both events not found');\n    }\n\n    return this.conflictDetector.checkEventPairConflicts(event1, event2, options);\n  }\n\n  /**\n   * Get all conflicts in a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {import('../../types.js').ConflictCheckOptions} [options={}] - Check options\n   * @returns {import('../../types.js').ConflictSummary} All conflicts in range\n   */\n  getAllConflicts(start, end, options = {}) {\n    const events = this.getEventsInRange(start, end, false);\n    const allConflicts = [];\n    const checkedPairs = new Set();\n\n    for (let i = 0; i < events.length; i++) {\n      for (let j = i + 1; j < events.length; j++) {\n        const pairKey = `${events[i].id}-${events[j].id}`;\n        if (!checkedPairs.has(pairKey)) {\n          checkedPairs.add(pairKey);\n          const conflicts = this.conflictDetector.checkEventPairConflicts(\n            events[i],\n            events[j],\n            options\n          );\n          allConflicts.push(...conflicts);\n        }\n      }\n    }\n\n    return this.conflictDetector._buildConflictSummary(\n      allConflicts,\n      new Set(events.map(e => e.id)),\n      new Set()\n    );\n  }\n\n  /**\n   * Get busy periods for attendees\n   * @param {string[]} attendeeEmails - Attendee emails\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date, eventIds: string[]}>} Busy periods\n   */\n  getBusyPeriods(attendeeEmails, start, end, options = {}) {\n    return this.conflictDetector.getBusyPeriods(attendeeEmails, start, end, options);\n  }\n\n  /**\n   * Get free periods for scheduling\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {number} durationMinutes - Required duration in minutes\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{start: Date, end: Date}>} Free periods\n   */\n  getFreePeriods(start, end, durationMinutes, options = {}) {\n    return this.conflictDetector.getFreePeriods(start, end, durationMinutes, options);\n  }\n\n  /**\n   * Add event with conflict checking\n   * @param {Event|import('../../types.js').EventData} event - Event to add\n   * @param {boolean} [allowConflicts=true] - Whether to allow adding with conflicts\n   * @returns {{event: Event, conflicts: import('../../types.js').ConflictSummary}} Result\n   */\n  addEventWithConflictCheck(event, allowConflicts = true) {\n    // Check conflicts before adding\n    const conflicts = this.checkConflicts(event);\n\n    if (!allowConflicts && conflicts.hasConflicts) {\n      throw new Error(`Cannot add event: ${conflicts.totalConflicts} conflicts detected`);\n    }\n\n    // Add the event\n    const addedEvent = this.addEvent(event);\n\n    return {\n      event: addedEvent,\n      conflicts\n    };\n  }\n\n  /**\n   * Find events with conflicts\n   * @param {Object} [options={}] - Options\n   * @returns {Array<{event: Event, conflicts: import('../../types.js').ConflictDetails[]}>} Events with conflicts\n   */\n  findEventsWithConflicts(options = {}) {\n    const eventsWithConflicts = [];\n    const allEvents = this.getAllEvents();\n\n    for (const event of allEvents) {\n      const conflicts = this.checkConflicts(event, options);\n      if (conflicts.hasConflicts) {\n        eventsWithConflicts.push({\n          event,\n          conflicts: conflicts.conflicts\n        });\n      }\n    }\n\n    return eventsWithConflicts;\n  }\n}","/**\n * StateManager - Central state management for the calendar\n * Implements an immutable state pattern with change notifications\n */\nexport class StateManager {\n  /**\n   * Create a new StateManager instance\n   * @param {Partial<import('../../types.js').CalendarState>} [initialState={}] - Initial state values\n   */\n  constructor(initialState = {}) {\n    this.state = {\n      // Current view configuration\n      view: 'month', // 'month', 'week', 'day', 'list'\n      currentDate: new Date(),\n\n      // UI state\n      selectedEventId: null,\n      selectedDate: null,\n      hoveredEventId: null,\n      hoveredDate: null,\n\n      // Display options\n      weekStartsOn: 0, // 0 = Sunday, 1 = Monday, etc.\n      showWeekNumbers: false,\n      showWeekends: true,\n      fixedWeekCount: true, // Always show 6 weeks in month view\n\n      // Time configuration\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      locale: 'en-US',\n      hourFormat: '12h', // '12h' or '24h'\n\n      // Business hours (for week/day views)\n      businessHours: {\n        start: '09:00',\n        end: '17:00'\n      },\n\n      // Filters\n      filters: {\n        searchTerm: '',\n        categories: [],\n        showAllDay: true,\n        showTimed: true\n      },\n\n      // Interaction flags\n      isDragging: false,\n      isResizing: false,\n      isCreating: false,\n\n      // Loading states\n      isLoading: false,\n      loadingMessage: '',\n\n      // Error state\n      error: null,\n\n      // Custom metadata\n      metadata: {},\n\n      // Apply initial state overrides\n      ...initialState\n    };\n\n    // Observers for state changes\n    this.listeners = new Map();\n    this.globalListeners = new Set();\n\n    // History for undo/redo (optional)\n    this.history = [];\n    this.historyIndex = -1;\n    this.maxHistorySize = 50;\n  }\n\n  /**\n   * Get the current state\n   * @returns {import('../../types.js').CalendarState} Current state (frozen)\n   */\n  getState() {\n    return Object.freeze({ ...this.state });\n  }\n\n  /**\n   * Get a specific state value\n   * @param {keyof import('../../types.js').CalendarState} key - The state key\n   * @returns {any} The state value\n   */\n  get(key) {\n    return this.state[key];\n  }\n\n  /**\n   * Update state with partial updates\n   * @param {Object|Function} updates - Object with updates or updater function\n   */\n  setState(updates) {\n    const oldState = this.state;\n\n    // Support function updater pattern\n    if (typeof updates === 'function') {\n      updates = updates(oldState);\n    }\n\n    // Create new state with updates\n    const newState = {\n      ...oldState,\n      ...updates,\n      // Preserve nested objects\n      filters: updates.filters ? { ...oldState.filters, ...updates.filters } : oldState.filters,\n      businessHours: updates.businessHours ? { ...oldState.businessHours, ...updates.businessHours } : oldState.businessHours,\n      metadata: updates.metadata ? { ...oldState.metadata, ...updates.metadata } : oldState.metadata\n    };\n\n    // Check if state actually changed\n    if (this._hasChanged(oldState, newState)) {\n      this.state = newState;\n\n      // Add to history (store the new state)\n      this._addToHistory(newState);\n\n      // Notify listeners\n      this._notifyListeners(oldState, newState);\n    }\n  }\n\n  /**\n   * Set the current view\n   * @param {string} view - The view type\n   */\n  setView(view) {\n    const validViews = ['month', 'week', 'day', 'list'];\n    if (!validViews.includes(view)) {\n      throw new Error(`Invalid view: ${view}. Must be one of: ${validViews.join(', ')}`);\n    }\n    this.setState({ view });\n  }\n\n  /**\n   * Set the current date\n   * @param {Date} date - The date to set\n   */\n  setCurrentDate(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n    if (isNaN(date.getTime())) {\n      throw new Error('Invalid date');\n    }\n    this.setState({ currentDate: date });\n  }\n\n  /**\n   * Navigate to the next period (month/week/day based on view)\n   */\n  navigateNext() {\n    const { view, currentDate } = this.state;\n    const newDate = new Date(currentDate);\n\n    switch (view) {\n      case 'month':\n        newDate.setMonth(newDate.getMonth() + 1);\n        break;\n      case 'week':\n        newDate.setDate(newDate.getDate() + 7);\n        break;\n      case 'day':\n        newDate.setDate(newDate.getDate() + 1);\n        break;\n    }\n\n    this.setCurrentDate(newDate);\n  }\n\n  /**\n   * Navigate to the previous period\n   */\n  navigatePrevious() {\n    const { view, currentDate } = this.state;\n    const newDate = new Date(currentDate);\n\n    switch (view) {\n      case 'month':\n        newDate.setMonth(newDate.getMonth() - 1);\n        break;\n      case 'week':\n        newDate.setDate(newDate.getDate() - 7);\n        break;\n      case 'day':\n        newDate.setDate(newDate.getDate() - 1);\n        break;\n    }\n\n    this.setCurrentDate(newDate);\n  }\n\n  /**\n   * Navigate to today\n   */\n  navigateToday() {\n    this.setCurrentDate(new Date());\n  }\n\n  /**\n   * Select an event\n   * @param {string} eventId - The event ID to select\n   */\n  selectEvent(eventId) {\n    this.setState({ selectedEventId: eventId });\n  }\n\n  /**\n   * Clear event selection\n   */\n  clearEventSelection() {\n    this.setState({ selectedEventId: null });\n  }\n\n  /**\n   * Select a date\n   * @param {Date} date - The date to select\n   */\n  selectDate(date) {\n    if (!(date instanceof Date)) {\n      date = new Date(date);\n    }\n    this.setState({ selectedDate: date });\n  }\n\n  /**\n   * Clear date selection\n   */\n  clearDateSelection() {\n    this.setState({ selectedDate: null });\n  }\n\n  /**\n   * Set loading state\n   * @param {boolean} isLoading - Loading state\n   * @param {string} message - Optional loading message\n   */\n  setLoading(isLoading, message = '') {\n    this.setState({\n      isLoading,\n      loadingMessage: message\n    });\n  }\n\n  /**\n   * Set error state\n   * @param {Error|string|null} error - The error\n   */\n  setError(error) {\n    this.setState({\n      error: error ? (error instanceof Error ? error.message : error) : null\n    });\n  }\n\n  /**\n   * Update filters\n   * @param {Object} filters - Filter updates\n   */\n  updateFilters(filters) {\n    this.setState({\n      filters: {\n        ...this.state.filters,\n        ...filters\n      }\n    });\n  }\n\n  /**\n   * Subscribe to all state changes\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  subscribe(callback) {\n    this.globalListeners.add(callback);\n\n    return () => {\n      this.globalListeners.delete(callback);\n    };\n  }\n\n  /**\n   * Subscribe to specific state key changes\n   * @param {string|string[]} keys - State key(s) to watch\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  watch(keys, callback) {\n    const keyArray = Array.isArray(keys) ? keys : [keys];\n\n    keyArray.forEach(key => {\n      if (!this.listeners.has(key)) {\n        this.listeners.set(key, new Set());\n      }\n      this.listeners.get(key).add(callback);\n    });\n\n    return () => {\n      keyArray.forEach(key => {\n        const callbacks = this.listeners.get(key);\n        if (callbacks) {\n          callbacks.delete(callback);\n          if (callbacks.size === 0) {\n            this.listeners.delete(key);\n          }\n        }\n      });\n    };\n  }\n\n  /**\n   * Check if undo is available\n   * @returns {boolean} True if undo is available\n   */\n  canUndo() {\n    return this.historyIndex > 0;\n  }\n\n  /**\n   * Check if redo is available\n   * @returns {boolean} True if redo is available\n   */\n  canRedo() {\n    return this.historyIndex < this.history.length - 1;\n  }\n\n  /**\n   * Get the number of undo operations available\n   * @returns {number} Number of undo operations\n   */\n  getUndoCount() {\n    return this.historyIndex;\n  }\n\n  /**\n   * Get the number of redo operations available\n   * @returns {number} Number of redo operations\n   */\n  getRedoCount() {\n    return this.history.length - 1 - this.historyIndex;\n  }\n\n  /**\n   * Undo the last state change\n   * @returns {boolean} True if undo was performed\n   */\n  undo() {\n    if (!this.canUndo()) {\n      return false;\n    }\n\n    this.historyIndex--;\n    const previousState = this.history[this.historyIndex];\n    const currentState = this.state;\n\n    // Update state without adding to history\n    this.state = { ...previousState };\n\n    // Notify listeners\n    this._notifyListeners(currentState, this.state);\n\n    return true;\n  }\n\n  /**\n   * Redo the next state change\n   * @returns {boolean} True if redo was performed\n   */\n  redo() {\n    if (!this.canRedo()) {\n      return false;\n    }\n\n    this.historyIndex++;\n    const nextState = this.history[this.historyIndex];\n    const currentState = this.state;\n\n    // Update state without adding to history\n    this.state = { ...nextState };\n\n    // Notify listeners\n    this._notifyListeners(currentState, this.state);\n\n    return true;\n  }\n\n  /**\n   * Reset state to initial values\n   */\n  reset() {\n    const initialState = this.history[0] || {};\n    this.setState(initialState);\n    this.history = [initialState];\n    this.historyIndex = 0;\n  }\n\n  /**\n   * Check if state has changed\n   * @private\n   */\n  _hasChanged(oldState, newState) {\n    return !this._deepEqual(oldState, newState);\n  }\n\n  /**\n   * Deep equality check optimized for state comparison\n   * @private\n   * @param {*} a - First value\n   * @param {*} b - Second value\n   * @param {Set} seen - Track circular references\n   * @returns {boolean} True if values are deeply equal\n   */\n  _deepEqual(a, b, seen = new Set()) {\n    // Same reference\n    if (a === b) return true;\n\n    // Different types or null/undefined\n    if (a == null || b == null) return a === b;\n    if (typeof a !== typeof b) return false;\n\n    // Primitives\n    if (typeof a !== 'object') return a === b;\n\n    // Check for circular references\n    if (seen.has(a) || seen.has(b)) return false;\n    seen.add(a);\n    seen.add(b);\n\n    // Arrays\n    if (Array.isArray(a)) {\n      if (!Array.isArray(b) || a.length !== b.length) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n\n      for (let i = 0; i < a.length; i++) {\n        if (!this._deepEqual(a[i], b[i], seen)) {\n          seen.delete(a);\n          seen.delete(b);\n          return false;\n        }\n      }\n\n      seen.delete(a);\n      seen.delete(b);\n      return true;\n    }\n\n    // Dates\n    if (a instanceof Date && b instanceof Date) {\n      const result = a.getTime() === b.getTime();\n      seen.delete(a);\n      seen.delete(b);\n      return result;\n    }\n\n    // Objects\n    const aKeys = Object.keys(a);\n    const bKeys = Object.keys(b);\n\n    if (aKeys.length !== bKeys.length) {\n      seen.delete(a);\n      seen.delete(b);\n      return false;\n    }\n\n    // Sort keys for consistent comparison\n    aKeys.sort();\n    bKeys.sort();\n\n    // Compare keys\n    for (let i = 0; i < aKeys.length; i++) {\n      if (aKeys[i] !== bKeys[i]) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n    }\n\n    // Compare values\n    for (const key of aKeys) {\n      if (!this._deepEqual(a[key], b[key], seen)) {\n        seen.delete(a);\n        seen.delete(b);\n        return false;\n      }\n    }\n\n    seen.delete(a);\n    seen.delete(b);\n    return true;\n  }\n\n  /**\n   * Add state to history\n   * @private\n   */\n  _addToHistory(state) {\n    // Remove any future history if we're not at the end\n    if (this.historyIndex < this.history.length - 1) {\n      this.history = this.history.slice(0, this.historyIndex + 1);\n    }\n\n    // Add new state\n    this.history.push({ ...state });\n    this.historyIndex++;\n\n    // Limit history size\n    if (this.history.length > this.maxHistorySize) {\n      this.history.shift();\n      this.historyIndex--;\n    }\n  }\n\n  /**\n   * Notify listeners of state changes\n   * @private\n   */\n  _notifyListeners(oldState, newState) {\n    // Notify global listeners\n    for (const callback of this.globalListeners) {\n      try {\n        callback(newState, oldState);\n      } catch (error) {\n        console.error('Error in state listener:', error);\n      }\n    }\n\n    // Notify specific key listeners\n    for (const [key, callbacks] of this.listeners) {\n      if (oldState[key] !== newState[key]) {\n        for (const callback of callbacks) {\n          try {\n            callback(newState[key], oldState[key], newState, oldState);\n          } catch (error) {\n            console.error(`Error in state listener for key \"${key}\":`, error);\n          }\n        }\n      }\n    }\n  }\n}","import { EventStore } from '../events/EventStore.js';\nimport { Event } from '../events/Event.js';\nimport { StateManager } from '../state/StateManager.js';\nimport { DateUtils } from './DateUtils.js';\nimport { TimezoneManager } from '../timezone/TimezoneManager.js';\n\n/**\n * Calendar - Main calendar class with full timezone support\n * Pure JavaScript, no DOM dependencies\n * Framework agnostic, Locker Service compatible\n */\nexport class Calendar {\n  /**\n   * Create a new Calendar instance\n   * @param {import('../../types.js').CalendarConfig} [config={}] - Configuration options\n   */\n  constructor(config = {}) {\n    // Initialize timezone manager first\n    this.timezoneManager = new TimezoneManager();\n\n    // Initialize configuration\n    this.config = {\n      view: 'month',\n      date: new Date(),\n      weekStartsOn: 0, // 0 = Sunday\n      locale: 'en-US',\n      timeZone: config.timeZone || this.timezoneManager.getSystemTimezone(),\n      showWeekNumbers: false,\n      showWeekends: true,\n      fixedWeekCount: true,\n      businessHours: {\n        start: '09:00',\n        end: '17:00'\n      },\n      ...config\n    };\n\n    // Initialize core components with timezone support\n    this.eventStore = new EventStore({ timezone: this.config.timeZone });\n    this.state = new StateManager({\n      view: this.config.view,\n      currentDate: this.config.date,\n      weekStartsOn: this.config.weekStartsOn,\n      locale: this.config.locale,\n      timeZone: this.config.timeZone,\n      showWeekNumbers: this.config.showWeekNumbers,\n      showWeekends: this.config.showWeekends,\n      fixedWeekCount: this.config.fixedWeekCount,\n      businessHours: this.config.businessHours\n    });\n\n    // Event emitter for calendar events\n    this.listeners = new Map();\n\n    // Plugins\n    this.plugins = new Set();\n\n    // View instances (lazy loaded)\n    this.views = new Map();\n\n    // Set up internal listeners\n    this._setupInternalListeners();\n\n    // Load initial events if provided\n    if (config.events) {\n      this.setEvents(config.events);\n    }\n  }\n\n  /**\n   * Set the calendar view\n   * @param {import('../../types.js').ViewType} viewType - The view type ('month', 'week', 'day', 'list')\n   * @param {Date} [date=null] - Optional date to navigate to\n   */\n  setView(viewType, date = null) {\n    this.state.setView(viewType);\n\n    if (date) {\n      this.state.setCurrentDate(date);\n    }\n\n    this._emit('viewChange', {\n      view: viewType,\n      date: date || this.state.get('currentDate')\n    });\n  }\n\n  /**\n   * Get the current view type\n   * @returns {import('../../types.js').ViewType} The current view type\n   */\n  getView() {\n    return this.state.get('view');\n  }\n\n  /**\n   * Navigate to the next period\n   */\n  next() {\n    this.state.navigateNext();\n    this._emit('navigate', {\n      direction: 'next',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to the previous period\n   */\n  previous() {\n    this.state.navigatePrevious();\n    this._emit('navigate', {\n      direction: 'previous',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to today\n   */\n  today() {\n    this.state.navigateToday();\n    this._emit('navigate', {\n      direction: 'today',\n      date: this.state.get('currentDate'),\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Navigate to a specific date\n   * @param {Date} date - The date to navigate to\n   */\n  goToDate(date) {\n    this.state.setCurrentDate(date);\n    this._emit('navigate', {\n      direction: 'goto',\n      date: date,\n      view: this.state.get('view')\n    });\n  }\n\n  /**\n   * Get the current date\n   * @returns {Date}\n   */\n  getCurrentDate() {\n    return new Date(this.state.get('currentDate'));\n  }\n\n  /**\n   * Add an event\n   * @param {import('../events/Event.js').Event|import('../../types.js').EventData} eventData - Event data or Event instance\n   * @returns {import('../events/Event.js').Event} The added event\n   */\n  addEvent(eventData) {\n    // If eventData is not an Event instance and doesn't have a timezone, use calendar's timezone\n    if (!(eventData instanceof Event) && !eventData.timeZone) {\n      eventData = { ...eventData, timeZone: this.config.timeZone };\n    }\n\n    const event = this.eventStore.addEvent(eventData);\n\n    this._emit('eventAdd', { event });\n\n    return event;\n  }\n\n  /**\n   * Update an event\n   * @param {string} eventId - The event ID\n   * @param {Object} updates - Properties to update\n   * @returns {Event} The updated event\n   */\n  updateEvent(eventId, updates) {\n    const oldEvent = this.eventStore.getEvent(eventId);\n    const event = this.eventStore.updateEvent(eventId, updates);\n\n    this._emit('eventUpdate', { event, oldEvent });\n\n    return event;\n  }\n\n  /**\n   * Remove an event\n   * @param {string} eventId - The event ID\n   * @returns {boolean} True if removed\n   */\n  removeEvent(eventId) {\n    const event = this.eventStore.getEvent(eventId);\n    const removed = this.eventStore.removeEvent(eventId);\n\n    if (removed) {\n      this._emit('eventRemove', { event });\n    }\n\n    return removed;\n  }\n\n  /**\n   * Get an event by ID\n   * @param {string} eventId - The event ID\n   * @returns {Event|null}\n   */\n  getEvent(eventId) {\n    return this.eventStore.getEvent(eventId);\n  }\n\n  /**\n   * Get all events\n   * @returns {Event[]}\n   */\n  getEvents() {\n    return this.eventStore.getAllEvents();\n  }\n\n  /**\n   * Set all events (replaces existing)\n   * @param {Event[]} events - Array of events\n   */\n  setEvents(events) {\n    this.eventStore.loadEvents(events);\n    this._emit('eventsSet', { events: this.getEvents() });\n  }\n\n  /**\n   * Query events with filters\n   * @param {Object} filters - Query filters\n   * @returns {Event[]}\n   */\n  queryEvents(filters) {\n    return this.eventStore.queryEvents(filters);\n  }\n\n  /**\n   * Get events for a specific date\n   * @param {Date} date - The date\n   * @param {string} [timezone] - Timezone for the query (defaults to calendar timezone)\n   * @returns {Event[]}\n   */\n  getEventsForDate(date, timezone = null) {\n    return this.eventStore.getEventsForDate(date, timezone || this.config.timeZone);\n  }\n\n  /**\n   * Get events in a date range\n   * @param {Date} start - Start date\n   * @param {Date} end - End date\n   * @param {string} [timezone] - Timezone for the query (defaults to calendar timezone)\n   * @returns {Event[]}\n   */\n  getEventsInRange(start, end, timezone = null) {\n    return this.eventStore.getEventsInRange(start, end, true, timezone || this.config.timeZone);\n  }\n\n  /**\n   * Set the calendar's timezone\n   * @param {string} timezone - IANA timezone identifier\n   */\n  setTimezone(timezone) {\n    const parsedTimezone = this.timezoneManager.parseTimezone(timezone);\n    const previousTimezone = this.config.timeZone;\n\n    this.config.timeZone = parsedTimezone;\n    this.eventStore.defaultTimezone = parsedTimezone;\n    this.state.setState({ timeZone: parsedTimezone });\n\n    this._emit('timezoneChange', {\n      timezone: parsedTimezone,\n      previousTimezone: previousTimezone\n    });\n  }\n\n  /**\n   * Get the current timezone\n   * @returns {string} Current timezone\n   */\n  getTimezone() {\n    return this.config.timeZone;\n  }\n\n  /**\n   * Convert a date from one timezone to another\n   * @param {Date} date - Date to convert\n   * @param {string} fromTimezone - Source timezone\n   * @param {string} toTimezone - Target timezone\n   * @returns {Date} Converted date\n   */\n  convertTimezone(date, fromTimezone, toTimezone) {\n    return this.timezoneManager.convertTimezone(date, fromTimezone, toTimezone);\n  }\n\n  /**\n   * Convert a date to the calendar's timezone\n   * @param {Date} date - Date to convert\n   * @param {string} fromTimezone - Source timezone\n   * @returns {Date} Date in calendar timezone\n   */\n  toCalendarTimezone(date, fromTimezone) {\n    return this.timezoneManager.convertTimezone(date, fromTimezone, this.config.timeZone);\n  }\n\n  /**\n   * Convert a date from the calendar's timezone\n   * @param {Date} date - Date in calendar timezone\n   * @param {string} toTimezone - Target timezone\n   * @returns {Date} Converted date\n   */\n  fromCalendarTimezone(date, toTimezone) {\n    return this.timezoneManager.convertTimezone(date, this.config.timeZone, toTimezone);\n  }\n\n  /**\n   * Format a date in a specific timezone\n   * @param {Date} date - Date to format\n   * @param {string} [timezone] - Timezone for formatting (defaults to calendar timezone)\n   * @param {Object} [options] - Formatting options\n   * @returns {string} Formatted date string\n   */\n  formatInTimezone(date, timezone = null, options = {}) {\n    return this.timezoneManager.formatInTimezone(\n      date,\n      timezone || this.config.timeZone,\n      options\n    );\n  }\n\n  /**\n   * Get list of common timezones with offsets\n   * @returns {Array<{value: string, label: string, offset: string}>} Timezone list\n   */\n  getTimezones() {\n    return this.timezoneManager.getCommonTimezones();\n  }\n\n  /**\n   * Get overlapping event groups for a date\n   * @param {Date} date - The date to check\n   * @param {boolean} timedOnly - Only include timed events\n   * @returns {Array<Event[]>} Array of event groups that overlap\n   */\n  getOverlapGroups(date, timedOnly = true) {\n    return this.eventStore.getOverlapGroups(date, timedOnly);\n  }\n\n  /**\n   * Calculate event positions for rendering\n   * @param {Event[]} events - Array of overlapping events\n   * @returns {Map<string, {column: number, totalColumns: number}>} Position data\n   */\n  calculateEventPositions(events) {\n    return this.eventStore.calculateEventPositions(events);\n  }\n\n  /**\n   * Get the current view's data\n   * @returns {import('../../types.js').MonthViewData|import('../../types.js').WeekViewData|import('../../types.js').DayViewData|import('../../types.js').ListViewData|null} View-specific data\n   */\n  getViewData() {\n    const view = this.state.get('view');\n    const currentDate = this.state.get('currentDate');\n\n    switch (view) {\n      case 'month':\n        return this._getMonthViewData(currentDate);\n      case 'week':\n        return this._getWeekViewData(currentDate);\n      case 'day':\n        return this._getDayViewData(currentDate);\n      case 'list':\n        return this._getListViewData(currentDate);\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Get month view data\n   * @private\n   */\n  _getMonthViewData(date) {\n    const year = date.getFullYear();\n    const month = date.getMonth();\n    const weekStartsOn = this.state.get('weekStartsOn');\n    const fixedWeekCount = this.state.get('fixedWeekCount');\n\n    // Get the first day of the month\n    const firstDay = new Date(year, month, 1);\n\n    // Get the last day of the month\n    const lastDay = new Date(year, month + 1, 0);\n\n    // Calculate the start date (beginning of the week containing the first day)\n    const startDate = DateUtils.startOfWeek(firstDay, weekStartsOn);\n\n    // Calculate weeks\n    const weeks = [];\n    let currentDate = new Date(startDate);\n\n    // Generate weeks\n    const maxWeeks = fixedWeekCount ? 6 : Math.ceil((lastDay.getDate() + DateUtils.getDayOfWeek(firstDay, weekStartsOn)) / 7);\n\n    for (let weekIndex = 0; weekIndex < maxWeeks; weekIndex++) {\n      const week = {\n        weekNumber: DateUtils.getWeekNumber(currentDate),\n        days: []\n      };\n\n      for (let dayIndex = 0; dayIndex < 7; dayIndex++) {\n        const dayDate = new Date(currentDate);\n        const isCurrentMonth = dayDate.getMonth() === month;\n        const isToday = DateUtils.isToday(dayDate);\n        const isWeekend = dayDate.getDay() === 0 || dayDate.getDay() === 6;\n\n        week.days.push({\n          date: dayDate,\n          dayOfMonth: dayDate.getDate(),\n          isCurrentMonth,\n          isToday,\n          isWeekend,\n          events: this.getEventsForDate(dayDate)\n        });\n\n        // Use DateUtils.addDays to handle month boundaries correctly\n        currentDate = DateUtils.addDays(currentDate, 1);\n      }\n\n      weeks.push(week);\n    }\n\n    return {\n      type: 'month',\n      year,\n      month,\n      monthName: DateUtils.getMonthName(date, this.state.get('locale')),\n      weeks,\n      startDate,\n      endDate: new Date(currentDate.getTime() - 1) // Last moment of the view\n    };\n  }\n\n  /**\n   * Get week view data\n   * @private\n   */\n  _getWeekViewData(date) {\n    const weekStartsOn = this.state.get('weekStartsOn');\n    const startDate = DateUtils.startOfWeek(date, weekStartsOn);\n    const endDate = DateUtils.endOfWeek(date, weekStartsOn);\n\n    const days = [];\n    const currentDate = new Date(startDate);\n\n    for (let i = 0; i < 7; i++) {\n      const dayDate = new Date(currentDate);\n      days.push({\n        date: dayDate,\n        dayOfMonth: dayDate.getDate(),\n        dayOfWeek: dayDate.getDay(),\n        dayName: DateUtils.getDayName(dayDate, this.state.get('locale')),\n        isToday: DateUtils.isToday(dayDate),\n        isWeekend: dayDate.getDay() === 0 || dayDate.getDay() === 6,\n        events: this.getEventsForDate(dayDate),\n        // Add overlap groups for positioning overlapping events\n        overlapGroups: this.eventStore.getOverlapGroups(dayDate, true),\n        getEventPositions: (events) => this.eventStore.calculateEventPositions(events)\n      });\n      // Move to next day\n      currentDate.setDate(currentDate.getDate() + 1);\n    }\n\n    return {\n      type: 'week',\n      weekNumber: DateUtils.getWeekNumber(startDate),\n      startDate,\n      endDate,\n      days\n    };\n  }\n\n  /**\n   * Get day view data\n   * @private\n   */\n  _getDayViewData(date) {\n    const events = this.getEventsForDate(date);\n\n    // Separate all-day and timed events\n    const allDayEvents = events.filter(e => e.allDay);\n    const timedEvents = events.filter(e => !e.allDay);\n\n    // Create hourly slots for timed events\n    const hours = [];\n    for (let hour = 0; hour < 24; hour++) {\n      const hourDate = new Date(date);\n      hourDate.setHours(hour, 0, 0, 0);\n      const hourEnd = new Date(date);\n      hourEnd.setHours(hour + 1, 0, 0, 0);\n\n      hours.push({\n        hour,\n        time: DateUtils.formatTime(hourDate, this.state.get('locale')),\n        events: timedEvents.filter(event => {\n          // Check if event occurs during this hour (not just starts)\n          // Event occurs in this hour if it overlaps with the hour slot\n          return event.start < hourEnd && event.end > hourDate;\n        })\n      });\n    }\n\n    return {\n      type: 'day',\n      date,\n      dayName: DateUtils.getDayName(date, this.state.get('locale')),\n      isToday: DateUtils.isToday(date),\n      allDayEvents,\n      hours\n    };\n  }\n\n  /**\n   * Get list view data\n   * @private\n   */\n  _getListViewData(date) {\n    // Get events for the next 30 days\n    const startDate = new Date(date);\n    startDate.setHours(0, 0, 0, 0);\n\n    const endDate = new Date(startDate);\n    endDate.setDate(endDate.getDate() + 30);\n\n    const events = this.getEventsInRange(startDate, endDate);\n\n    // Group events by day\n    const groupedEvents = new Map();\n\n    events.forEach(event => {\n      const dateKey = event.start.toDateString();\n      if (!groupedEvents.has(dateKey)) {\n        groupedEvents.set(dateKey, {\n          date: new Date(event.start),\n          events: []\n        });\n      }\n      groupedEvents.get(dateKey).events.push(event);\n    });\n\n    // Convert to sorted array\n    const days = Array.from(groupedEvents.values())\n      .sort((a, b) => a.date - b.date)\n      .map(day => ({\n        ...day,\n        dayName: DateUtils.getDayName(day.date, this.state.get('locale')),\n        isToday: DateUtils.isToday(day.date)\n      }));\n\n    return {\n      type: 'list',\n      startDate,\n      endDate,\n      days,\n      totalEvents: events.length\n    };\n  }\n\n  /**\n   * Select an event\n   * @param {string} eventId - Event ID to select\n   */\n  selectEvent(eventId) {\n    const event = this.getEvent(eventId);\n    if (event) {\n      this.state.selectEvent(eventId);\n      this._emit('eventSelect', { event });\n    }\n  }\n\n  /**\n   * Clear event selection\n   */\n  clearEventSelection() {\n    const eventId = this.state.get('selectedEventId');\n    this.state.clearEventSelection();\n\n    if (eventId) {\n      this._emit('eventDeselect', { eventId });\n    }\n  }\n\n  /**\n   * Select a date\n   * @param {Date} date - Date to select\n   */\n  selectDate(date) {\n    this.state.selectDate(date);\n    this._emit('dateSelect', { date });\n  }\n\n  /**\n   * Clear date selection\n   */\n  clearDateSelection() {\n    const date = this.state.get('selectedDate');\n    this.state.clearDateSelection();\n\n    if (date) {\n      this._emit('dateDeselect', { date });\n    }\n  }\n\n  /**\n   * Subscribe to calendar events\n   * @param {string} eventName - Event name\n   * @param {Function} callback - Callback function\n   * @returns {Function} Unsubscribe function\n   */\n  on(eventName, callback) {\n    if (!this.listeners.has(eventName)) {\n      this.listeners.set(eventName, new Set());\n    }\n    this.listeners.get(eventName).add(callback);\n\n    return () => this.off(eventName, callback);\n  }\n\n  /**\n   * Unsubscribe from calendar events\n   * @param {string} eventName - Event name\n   * @param {Function} callback - Callback function\n   */\n  off(eventName, callback) {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.delete(callback);\n      if (callbacks.size === 0) {\n        this.listeners.delete(eventName);\n      }\n    }\n  }\n\n  /**\n   * Emit an event\n   * @private\n   */\n  _emit(eventName, data) {\n    const callbacks = this.listeners.get(eventName);\n    if (callbacks) {\n      callbacks.forEach(callback => {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error(`Error in event listener for \"${eventName}\":`, error);\n        }\n      });\n    }\n  }\n\n  /**\n   * Set up internal listeners\n   * @private\n   */\n  _setupInternalListeners() {\n    // Listen to state changes\n    this.state.subscribe((newState, oldState) => {\n      this._emit('stateChange', { newState, oldState });\n    });\n\n    // Listen to event store changes\n    this.eventStore.subscribe((change) => {\n      this._emit('eventStoreChange', change);\n    });\n  }\n\n  /**\n   * Install a plugin\n   * @param {Object} plugin - Plugin object with install method\n   */\n  use(plugin) {\n    if (this.plugins.has(plugin)) {\n      console.warn('Plugin already installed');\n      return;\n    }\n\n    if (typeof plugin.install === 'function') {\n      plugin.install(this);\n      this.plugins.add(plugin);\n    } else {\n      throw new Error('Plugin must have an install method');\n    }\n  }\n\n  /**\n   * Destroy the calendar and clean up\n   */\n  destroy() {\n    // Clear all listeners\n    this.listeners.clear();\n\n    // Clear stores\n    this.eventStore.clear();\n\n    // Clear plugins\n    this.plugins.forEach(plugin => {\n      if (typeof plugin.uninstall === 'function') {\n        plugin.uninstall(this);\n      }\n    });\n    this.plugins.clear();\n\n    this._emit('destroy');\n  }\n}// Test workflow\n","/**\n * Lightning Calendar Core - Main entry point\n * A modern, lightweight, framework-agnostic calendar library\n * Optimized for Salesforce Lightning and Locker Service\n */\n\n// Core exports\nexport { Calendar } from './calendar/Calendar.js';\nexport { Event } from './events/Event.js';\nexport { EventStore } from './events/EventStore.js';\nexport { StateManager } from './state/StateManager.js';\nexport { DateUtils } from './calendar/DateUtils.js';\n\n// Version\nexport const VERSION = '0.1.0';\n\n// Default export\nexport { Calendar as default } from './calendar/Calendar.js';"],"names":["TimezoneDatabase","constructor","this","timezones","UTC","offset","dst","GMT","start","month","week","day","end","aliases","EST","EDT","CST","CDT","MST","MDT","PST","PDT","AKST","AKDT","HST","AST","ADT","NST","NDT","BST","IST","WET","WEST","CET","CEST","EET","EEST","MSK","JST","KST","CST_CN","HKT","SGT","AEST","AEDT","ACST","ACDT","AWST","NZST","NZDT","GB","Eire","Israel","Japan","Singapore","Hongkong","ROK","PRC","NZ","getTimezone","timezone","getAllTimezones","Object","keys","isValidTimezone","undefined","resolveAlias","getTimezonesByOffset","offsetMinutes","entries","filter","_","data","map","id","getCommonTimezones","Americas","Europe","Asia","Africa","TimezoneManager","database","offsetCache","Map","dstCache","maxCacheSize","cacheHits","cacheMisses","convertTimezone","date","fromTimezone","toTimezone","Date","fromOffset","getTimezoneOffset","offsetDiff","getTime","toUTC","fromUTC","utcDate","cacheKey","getFullYear","getMonth","getDate","has","_manageCacheSize","get","Intl","DateTimeFormat","parts","timeZone","year","hour","minute","second","hour12","formatToParts","find","p","type","value","set","e","tzData","Error","isDST","dstRule","dstStart","getNthWeekdayOfMonth","dstEnd","dayOfWeek","dayOffset","getDay","setDate","lastDay","now","label","region","tz","offsetHours","hours","Math","floor","abs","minutes","round","offsetStr","toString","padStart","sort","a","b","formatInTimezone","options","formatOptions","format","toLocaleString","getSystemTimezone","resolvedOptions","tzOffset","timezoneOffsets","parseTimezone","tzString","hasOwnProperty","upperTz","toUpperCase","timezoneAbbreviations","offsetMatch","match","totalOffset","parseInt","getTimezoneDifference","timezone1","timezone2","offset1","clearCache","clear","getCacheStats","hitRate","toFixed","offsetCacheSize","size","dstCacheSize","entriesToRemove","Array","from","i","delete","Event","normalize","normalized","allDay","setHours","String","trim","title","description","location","attendees","isArray","reminders","categories","attachments","includes","status","visibility","color","backgroundColor","borderColor","validate","isNaN","recurring","recurrenceRule","length","forEach","attendee","index","email","name","test","reminder","method","minutesBefore","textColor","endTimeZone","organizer","conferenceData","metadata","_timezoneManager","startUTC","endUTC","_originalTimeZone","_cache","_validateAttendees","_validateReminders","duration","getStartInTimezone","getEndInTimezone","updateTimes","durationMinutes","durationHours","isMultiDay","startDay","toDateString","endDay","isRecurring","occursOn","dateString","startString","endString","dayStart","dayEnd","overlaps","otherEvent","contains","datetime","clone","updates","r","toObject","toISOString","fromObject","obj","equals","other","addAttendee","hasAttendee","random","substr","responseStatus","role","push","removeAttendee","emailOrId","findIndex","splice","updateAttendeeResponse","getAttendee","responseTime","some","getAttendeesByStatus","getAttendeeCounts","reduce","counts","addReminder","enabled","removeReminder","reminderId","getActiveReminders","getReminderTriggerTimes","triggerTime","setMinutes","getMinutes","addCategory","category","normalizedCategory","toLowerCase","hasCategory","removeCategory","c","hasAnyCategory","hasAllCategories","every","_isValidEmail","isCancelled","isTentative","isConfirmed","isPrivate","isPublic","hasAttendees","hasReminders","isMeeting","isVirtual","DateUtils","startOfDay","result","endOfDay","startOfWeek","weekStartsOn","diff","setTime","endOfWeek","startOfMonth","endOfMonth","startOfYear","endOfYear","addDays","days","addWeeks","weeks","addMonths","months","dayOfMonth","setMonth","addYears","years","setFullYear","getUTCDateString","getUTCFullYear","getUTCMonth","getUTCDate","getLocalDateString","isToday","today","isPast","isFuture","isSameDay","date1","date2","isSameWeek","week1Start","week2Start","isSameMonth","isSameYear","differenceInDays","differenceInWeeks","differenceInMonths","getWeekNumber","firstDayOfYear","pastDaysOfYear","ceil","getDayOfWeek","getDaysInMonth","locale","getMonthName","getDayName","weekday","formatTime","use24Hour","parseTime","timeString","split","Number","isLeapYear","getDateRange","dates","current","endTime","isValidDate","toTimeZone","dateObj","part","tzDate","jan","jul","janOffset","julOffset","currentOffset","max","addHoursWithDST","originalOffset","newOffset","dstAdjustment","createInTimeZone","dateStr","timeStr","localDate","utcTime","RRuleParser","parse","rrule","validateRule","rule","freq","interval","count","until","byDay","byWeekNo","byMonth","byMonthDay","byYearDay","bySetPos","byHour","byMinute","bySecond","wkst","exceptions","tzid","key","parseFrequency","parseDateTime","parseByDay","parseIntList","parseExceptionDates","weekDays","nth","v","validateArray","arr","min","buildRRule","formatDateTime","dayStr","d","join","getUTCHours","getUTCMinutes","getUTCSeconds","getDescription","weekdayMap","SU","MO","TU","WE","TH","FR","SA","nthMap","SECONDLY","MINUTELY","HOURLY","DAILY","WEEKLY","MONTHLY","YEARLY","monthNames","m","toLocaleDateString","RecurrenceEngine","expandEvent","event","rangeStart","rangeEnd","maxOccurrences","parseRule","occurrences","eventTimezone","tzManager","currentDate","lastOffset","occurrenceStart","occurrenceEnd","isException","recurringEventId","originalStart","getNextOccurrence","ruleString","next","matchesByDay","currentMonth","setToWeekdayOfMonth","dayMap","weekdayCode","position","targetDay","nextMonth","eventId","dateTime","exDate","exceptionDate","matchTime","addExceptions","reason","parseDate","endsWith","dayCode","code","LRUCache","capacity","cache","hits","misses","evictions","put","firstKey","getStats","AdaptiveMemoryManager","config","checkInterval","memoryThreshold","criticalThreshold","minCacheSize","adaptiveScaling","caches","stats","adjustments","emergencyClears","lastMemoryUsage","lastCheckTime","cacheResizes","monitoringInterval","startMonitoring","registerCache","priority","currentCapacity","initialCapacity","minCapacity","maxCapacity","scaleFactor","lastAccess","unregisterCache","setInterval","checkMemoryPressure","stopMonitoring","clearInterval","memoryUsage","getMemoryUsage","emergencyClear","reduceCacheSizes","increaseCacheSizes","performance","memory","memInfo","jsHeapSizeLimit","usedJSHeapSize","process","usage","heapUsed","heapTotal","estimateMemoryUsage","totalItems","maxItems","cacheInfo","pressureLevel","sortedCaches","reduction","newCapacity","resizeCache","increase","oldCapacity","evictExcessItems","timestamp","shift","targetSize","itemsToRemove","console","warn","touchCache","cacheStats","memoryUsagePercent","totalCaches","monitoring","checkNow","setThresholds","thresholds","destroy","PerformanceOptimizer","enableCache","cacheCapacity","maxIndexDays","batchSize","enableMetrics","cleanupInterval","maxIndexAge","enableAdaptiveMemory","eventCache","queryCache","dateRangeCache","memoryManager","lazyIndexes","pendingIndexes","batchQueue","batchTimer","batchCallbacks","metrics","operations","averageTimes","slowQueries","cleanupTimer","startCleanupTimer","measure","operation","fn","recordMetric","error","measureAsync","isError","totalTime","errors","Infinity","metric","getMetrics","summary","query","dateRange","slowestOperations","recentSlowQueries","slice","memoryManagement","op","avgTime","minTime","maxTime","errorRate","time","shouldUseLazyIndexing","createLazyIndexMarkers","markers","indexed","Set","pending","startMonth","endMonth","add","getMonthKey","expandLazyIndex","promise","Promise","resolve","setTimeout","cacheType","cacheManagerName","getFromCache","invalidateEventCaches","batch","reject","processBatch","clearTimeout","callbacks","results","callback","cleanupOldIndexes","maxAge","optimizeQuery","queryKey","queryFn","cached","ConflictDetector","eventStore","conflictIdCounter","checkConflicts","opts","checkAttendees","checkResources","checkLocation","ignoreAllDay","excludeEventIds","includeStatuses","bufferMinutes","conflicts","affectedEventIds","affectedAttendees","searchStart","searchEnd","potentialConflicts","getEventsInRange","conflictingEvent","eventConflicts","_detectEventConflicts","_buildConflictSummary","checkEventPairConflicts","event1","event2","getBusyPeriods","attendeeEmails","mergePeriods","busyPeriods","eventIds","_mergeBusyPeriods","getFreePeriods","businessHoursOnly","businessHours","excludeWeekends","freePeriods","_getAllBusyPeriods","currentTime","busy","_isWithinBusinessHours","_checkTimeOverlap","timeConflict","_createTimeConflict","attendeeConflicts","_checkAttendeeConflicts","resourceConflicts","_checkResourceConflicts","locationConflict","_checkLocationConflict","buffer","start1","end1","start2","end2","overlapStart","overlapEnd","overlapMinutes","severity","conflictingEventId","event1Title","event2Title","event1Status","event2Status","conflictingAttendees","attendee1","attendee2","a1","a2","attendeeCount","resources1","resource","resources2","resource1","resource2","conflictingResource","resourceName","resourceEmail","conflictsByType","conflictsBySeverity","conflict","hasConflicts","totalConflicts","periods","merged","last","startHour","getHours","endHour","businessStart","businessEnd","EventStore","events","indices","byDate","byCategory","byStatus","timezoneManager","defaultTimezone","optimizer","conflictDetector","isBatchMode","batchNotifications","batchBackup","version","listeners","addEvent","_indexEvent","_notifyChange","updateEvent","existingEvent","_unindexEvent","updatedEvent","oldEvent","removeEvent","getEvent","getAllEvents","values","queryEvents","filters","monthKey","matchAllCategories","organizerEmail","localeCompare","getEventsForDate","allEvents","checkDate","tempDate","tempDateStr","eventStartLocal","eventEndLocal","timeCompare","getOverlappingEvents","excludeId","overlapping","startDate","endDate","checkedIds","getOverlapGroups","timedOnly","groups","processed","group","currentEvent","calculateEventPositions","positions","startDiff","columns","column","totalColumns","pos","expandRecurring","baseEvents","expandedEvents","expandRecurringEvent","occurrence","occurrenceIndex","oldEvents","loadEvents","eventData","subscribe","_indexEventLazy","firstWeekEnd","lastWeekStart","change","listener","totalEvents","recurringEvents","indexedDates","indexedMonths","indexedCategories","indexedStatuses","performanceMetrics","startBatch","enableRollback","k","commitBatch","changes","rollbackBatch","executeBatch","addEvents","message","updateEvents","eventUpdates","removeEvents","removed","getPerformanceMetrics","clearCaches","optimizeIndices","cutoffDate","stillNeeded","log","eventId1","eventId2","getAllConflicts","allConflicts","checkedPairs","j","pairKey","addEventWithConflictCheck","allowConflicts","findEventsWithConflicts","eventsWithConflicts","StateManager","initialState","state","view","selectedEventId","selectedDate","hoveredEventId","hoveredDate","showWeekNumbers","showWeekends","fixedWeekCount","hourFormat","searchTerm","showAllDay","showTimed","isDragging","isResizing","isCreating","isLoading","loadingMessage","globalListeners","history","historyIndex","maxHistorySize","getState","freeze","setState","oldState","newState","_hasChanged","_addToHistory","_notifyListeners","setView","validViews","setCurrentDate","navigateNext","newDate","navigatePrevious","navigateToday","selectEvent","clearEventSelection","selectDate","clearDateSelection","setLoading","setError","updateFilters","watch","keyArray","canUndo","canRedo","getUndoCount","getRedoCount","undo","previousState","currentState","redo","nextState","reset","_deepEqual","seen","aKeys","bKeys","Calendar","plugins","views","_setupInternalListeners","setEvents","viewType","_emit","getView","direction","previous","goToDate","getCurrentDate","getEvents","setTimezone","parsedTimezone","previousTimezone","toCalendarTimezone","fromCalendarTimezone","getTimezones","getViewData","_getMonthViewData","_getWeekViewData","_getDayViewData","_getListViewData","firstDay","maxWeeks","weekIndex","weekNumber","dayIndex","dayDate","isCurrentMonth","isWeekend","monthName","dayName","overlapGroups","getEventPositions","allDayEvents","timedEvents","hourDate","hourEnd","groupedEvents","dateKey","on","eventName","off","use","plugin","install","uninstall","VERSION"],"mappings":"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"}